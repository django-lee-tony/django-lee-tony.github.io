<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://django-lee-tony.github.io</id>
    <title>django </title>
    <updated>2021-02-06T09:13:01.205Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://django-lee-tony.github.io"/>
    <link rel="self" href="https://django-lee-tony.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://django-lee-tony.github.io/images/avatar.png</logo>
    <icon>https://django-lee-tony.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, django </rights>
    <entry>
        <title type="html"><![CDATA[react学习之 react-redux]]></title>
        <id>https://django-lee-tony.github.io/post/react-xue-xi-zhi-react-redux/</id>
        <link href="https://django-lee-tony.github.io/post/react-xue-xi-zhi-react-redux/">
        </link>
        <updated>2021-02-06T05:35:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="核心概念">核心概念</h1>
<p>redux专注于状态管理，把所有的状态都存在一个对象中。核心概念包括：store、state、action、reducer</p>
<h3 id="store">【store】</h3>
<p>store是保存数据的地方，redux提供createStore函数来生成 Store。函数参数是后面要介绍的reducer</p>
<pre><code>import { createStore } from 'redux'
const store = createStore(reducer)
</code></pre>
<h3 id="state">【state】</h3>
<p>state是store的某个时刻的快照，可以通过store.getState()取得当前时刻的state</p>
<pre><code>const state = store.getState()
</code></pre>
<h3 id="action">【action】</h3>
<p>action用来改变state。action是一个对象，其中的type属性是必须的，其他的属性一般用来设置改变state需要的数据</p>
<pre><code>const action = {
  type: 'ADD_ONE',
  num: 1
}
</code></pre>
<p>store.dispatch()是发出action的唯一方法</p>
<pre><code>const action = {
  type: 'ADD_ONE',
  num: 1
}
store.dispatch(action)
</code></pre>
<h3 id="reducer">【reducer】</h3>
<p>reducer 是一个函数，它接受action和当前state作为参数，返回一个新的state</p>
<pre><code>import { createStore } from 'redux'
const store = createStore(reducer)

const reducer = (state = 10, action) =&gt; {
  switch (action.type) {
    case 'ADD_ONE':
      return state + action.num;
    default: 
      return state;
  }
};
当store.dispatch发送过来一个新的action，store就会自动调用reducer，得到新的state
</code></pre>
<h2 id="简单实例">简单实例</h2>
<pre><code>//第一步，创建action
const addOne = {
  type: 'ADD',
  num: 1
}
const addTwo = {
  type: 'ADD',
  num: 2
}
const square = {
  type: 'SQUARE'
}
//第二步，创建reducer
let math = (state = 10, action) =&gt; {
  switch (action.type) {
    case ADD:
      return state + action.num
    case SQUARE:
      return state * state
    default:
      return state
  }
}
//第三步，创建store
import { createStore } from 'redux'
const store = createStore(math)
//第四步，测试，通过dispatch发出action，并通过getState()取得当前state值
console.log(store.getState()) //默认值为10
store.dispatch(addOne) //发起'+1'的action
console.log(store.getState()) //当前值为10+1=11
store.dispatch(square) //发起'乘方'的action
console.log(store.getState()) //当前值为11*11=121
store.dispatch(addTwo) //发起'+2'的action
console.log(store.getState()) //当前值为121+2=123
</code></pre>
<h2 id="目录结构">目录结构</h2>
<h3 id="下面对目录结构进行划分">下面对目录结构进行划分</h3>
<p>1、一般地，将action.type设置为常量，这样在书写错误时，会得到报错提示</p>
<pre><code>// constants/ActionTypes.js
export const ADD = 'ADD'
export const SQUARE = 'SQUARE'
</code></pre>
<p>2、可以将addOne对象和addTwo对象整合成add函数的形式</p>
<pre><code>// action/math.js
import { ADD, SQUARE } from '../constants/ActionTypes'
export const add = num =&gt; ({ type: ADD, num })
export const square = { type: SQUARE }
</code></pre>
<p>3、根据action.type的分类来拆分reducer，最终通过combineReducers方法将拆分的reducer合并起来。上例中的action类型都是数字运算，无需拆分，只需进行如下变化</p>
<pre><code>// reducer/math.js
import { ADD, SQUARE } from '../constants/ActionTypes'
const math = (state = 10, action) =&gt; {
  switch (action.type) {
    case ADD:
      return state + action.num
    case SQUARE:
      return state * state
    default:
      return state
  }
}
export default math
</code></pre>
<pre><code>// reducer/index.js
import { combineReducers } from 'redux'
import math from './math'
const rootReducer = combineReducers({
  math
})
export default rootReducer
</code></pre>
<p>4、将store存储到store/index.js文件中</p>
<pre><code>// store/index.js
import { createStore } from 'redux'
import rootReducer from '../reducer'
export default createStore(rootReducer)
</code></pre>
<p>5、最终，根路径下的index.js内容如下所示</p>
<pre><code>import store from './store'
import {add, square} from './action/math'

console.log(store.getState()) //默认值为10

store.dispatch(add(1)) //发起'+1'的action
console.log(store.getState()) //当前值为10+1=11

store.dispatch(square) //发起'乘方'的action
console.log(store.getState()) //当前值为11*11=121

store.dispatch(add(2)) //发起'+2'的action
console.log(store.getState()) //当前值为121+2=123
</code></pre>
<h2 id="ui层">UI层</h2>
<p>前面的示例中，只是redux的状态改变，下面利用UI层来建立view和state的联系，将根目录下的index.js的内容更改如下<br>
import store from './store'<br>
import React from 'react'<br>
import ReactDOM from 'react-dom'<br>
import { add, square } from './action/math'</p>
<p>ReactDOM.render(</p>
  <div store={store}>
    <p>{store.getState().math}</p>
    <input type="button" onClick={() => store.dispatch(add(1))} value="+1" />
    <input type="button" onClick={() => store.dispatch(add(2))} value="+2" />
    <input type="button" onClick={() => store.dispatch(square)} value="乘方" />
  </div>,
  document.getElementById('root')
)
### 【store.subscribe()】
接下来介绍store.subscribe()方法了，该方法用来设置监听函数，一旦state发生变化，就自动执行这个函数。该方法的返回值是一个函数，调用这个函数可以解除监听
下面将示例代码更改如下
```
import store from './store'
import React from 'react'
import ReactDOM from 'react-dom'
import { add, square } from './action/math'
<p>const render = () =&gt; ReactDOM.render(</p>
  <div store={store}>
    <p>{store.getState().math}</p>
    <input type="button" onClick={() => store.dispatch(add(1))} value="+1" />
    <input type="button" onClick={() => store.dispatch(add(2))} value="+2" />
    <input type="button" onClick={() => store.dispatch(square)} value="乘方" />
  </div>,
  document.getElementById('root')
)
<p>render()<br>
store.subscribe(render)</p>
<pre><code>## 异步
redux默认只处理同步，对于API请求这样的异步任务则无能为力
接下来尝试使用axios的get方法来请求下面这个API
</code></pre>
<p>复制代码<br>
// constants/ActionTypes.js<br>
export const ADD = 'ADD'<br>
export const SQUARE = 'SQUARE'<br>
export const SET = 'SET'</p>
<p>// action/math.js<br>
import { ADD, SQUARE, SET } from '../constants/ActionTypes'<br>
export const add = num =&gt; ({ type: ADD, num })<br>
export const square = { type: SQUARE }<br>
export const setNum = num =&gt; ({type: SET,num})</p>
<p>// reduce/math.js<br>
import { ADD, SQUARE,SET } from '../constants/ActionTypes'<br>
const math = (state = 10, action) =&gt; {<br>
switch (action.type) {<br>
case ADD:<br>
return state + action.num<br>
case SQUARE:<br>
return state * state<br>
case SET:<br>
return action.num<br>
default:<br>
return state<br>
}<br>
}<br>
export default math</p>
<p>// index.js<br>
import store from './store'<br>
import React from 'react'<br>
import ReactDOM from 'react-dom'<br>
import { add, square, setNum } from './action/math'<br>
import axios from 'axios'<br>
let uri = 'https://jsonplaceholder.typicode.com/posts/2'<br>
const render = () =&gt; ReactDOM.render(</p>
  <div store={store}>
    <p>{store.getState().math}</p>
    <input type="button" onClick={() => {axios.get(uri).then(res => {store.dispatch(store.dispatch(setNum(res.data.id)))})}} value="设置Num" />
    <input type="button" onClick={() => store.dispatch(add(1))} value="+1" />
    <input type="button" onClick={() => store.dispatch(add(2))} value="+2" />
    <input type="button" onClick={() => store.dispatch(square)} value="乘方" />
  </div>,
  document.getElementById('root')
)
render()
store.subscribe(render)
```
但是，虽然API是异步操作，但store.dispatch并不是异步，而axios通过get方法请求回来数据后，store.dispatch在axios中的then方法中同步取得数据
### 【redux-thunk】
如果要使用真正的异步操作，即把axios方法封装到store.dispatch中，需要使用redux-thunk中间件
````
//下载
npm install --save redux-thunk
```
然后，使用applyMiddleware来使用thunk中间件
```
 import { createStore, applyMiddleware } from 'redux'
import thunk from 'redux-thunk'
import rootReducer from '../reducer'
export default createStore(rootReducer,applyMiddleware(thunk))
```
　接着来定义setNum这个action creator，然后在index.js文件的DOM加载完成后就发出setNum
* [注意]如果action是一个对象，则它就是一个action，如果action是一个函数，则它是一个action creator，即action制造器
<p>修改的代码如下</p>
<pre><code>// action/math.js
import { ADD, SQUARE, SET } from '../constants/ActionTypes'
import axios from 'axios'
const uri = 'https://jsonplaceholder.typicode.com/posts/2'
export const add = num =&gt; ({ type: ADD, num })
export const square = { type: SQUARE }
export const setNum = () =&gt; (dispatch, getState) =&gt; {
  return axios.get(uri).then(res =&gt; {
    dispatch({
      type: SET,
      num: res.data.id
    })
  })
}

// index.js
import store from './store'
import React from 'react'
import ReactDOM from 'react-dom'
import { add, square, setNum } from './action/math'
const render = () =&gt; ReactDOM.render(
  &lt;div store={store}&gt;
    &lt;p&gt;{store.getState().math}&lt;/p&gt;
    &lt;input type=&quot;button&quot; onClick={() =&gt; store.dispatch(setNum())} value=&quot;设置Num&quot; /&gt;
    &lt;input type=&quot;button&quot; onClick={() =&gt; store.dispatch(add(1))} value=&quot;+1&quot; /&gt;
    &lt;input type=&quot;button&quot; onClick={() =&gt; store.dispatch(add(2))} value=&quot;+2&quot; /&gt;
    &lt;input type=&quot;button&quot; onClick={() =&gt; store.dispatch(square)} value=&quot;乘方&quot; /&gt;
  &lt;/div&gt;,
  document.getElementById('root')
)
render()
store.subscribe(render)

</code></pre>
<h3 id="提示信息">【提示信息】</h3>
<p>如果做的更完备一点，应该把异步请求时的提示信息也加上。增加一个fetch的action，用于控制fetch过程的提示信息及显示隐藏情况<br>
代码更改如下</p>
<pre><code>import { SET_FETCH_MESSAGE, HIDE_FETCH_MESSAGE } from '../constants/ActionTypes'
export const startFetch = { type: SET_FETCH_MESSAGE,message: '开始发送异步请求' }
export const successFetch = { type: SET_FETCH_MESSAGE, message: '成功接收数据' }
export const failFetch = { type: SET_FETCH_MESSAGE, message: '接收数据失败' }
export const hideFetchMessage = { type: HIDE_FETCH_MESSAGE }
</code></pre>
<pre><code>// action/math.js
import { ADD, SQUARE, SET } from '../constants/ActionTypes'
import { startFetch, successFetch, failFetch, hideFetchMessage } from './fetch'
import axios from 'axios'
const uri = 'https://jsonplaceholder.typicode.com/posts/2'
export const add = num =&gt; ({ type: ADD, num })
export const square = { type: SQUARE }
export const setNum = () =&gt; (dispatch, getState) =&gt; {
  dispatch(startFetch)
  setTimeout(() =&gt; {
    dispatch(hideFetchMessage)
  }, 500)
  return axios
    .get(uri)
    .then(res =&gt; {
      setTimeout(() =&gt; {
        dispatch(successFetch)
        setTimeout(() =&gt; {
          dispatch(hideFetchMessage)
        }, 500)
        dispatch({ type: SET, num: res.data.id })
      }, 1000)
    })
    .catch(err =&gt; {
      dispatch(failFetch)
      setTimeout(() =&gt; {
        dispatch(hideFetchMessage)
      }, 500)
    })
}

</code></pre>
<pre><code>// constants/ActionTypes.js
export const ADD = 'ADD'
export const SQUARE = 'SQUARE'
export const SET = 'SET'
export const SET_FETCH_MESSAGE = 'SET_FETCH_MESSAGE'
export const HIDE_FETCH_MESSAGE = 'HIDE_FETCH_MESSAGE'
</code></pre>
<pre><code>// reduce/fetch.js
import { SET_FETCH_MESSAGE,HIDE_FETCH_MESSAGE } from '../constants/ActionTypes'
const initState = {
  message:'',
  isShow:false
}
const fetch = (state = initState, action) =&gt; {
  switch (action.type) {
    case SET_FETCH_MESSAGE:
      return {isShow: true, message: action.message}
    case HIDE_FETCH_MESSAGE:
      return { isShow: false, message: '' }
    default:
      return state
  }
}
export default fetch
</code></pre>
<pre><code>// index.js
import store from './store'
import React from 'react'
import ReactDOM from 'react-dom'
import { add, square, setNum } from './action/math'
const render = () =&gt; ReactDOM.render(
  &lt;div store={store}&gt;
    &lt;p&gt;{store.getState().math}&lt;/p&gt;
    &lt;input type=&quot;button&quot; onClick={() =&gt; store.dispatch(setNum())} value=&quot;设置Num&quot; /&gt;
    &lt;input type=&quot;button&quot; onClick={() =&gt; store.dispatch(add(1))} value=&quot;+1&quot; /&gt;
    &lt;input type=&quot;button&quot; onClick={() =&gt; store.dispatch(add(2))} value=&quot;+2&quot; /&gt;
    &lt;input type=&quot;button&quot; onClick={() =&gt; store.dispatch(square)} value=&quot;乘方&quot; /&gt;
    {store.getState().fetch.isShow &amp;&amp; &lt;p&gt;{store.getState().fetch.message}&lt;/p&gt;}
  &lt;/div&gt;,
  document.getElementById('root')
)
render()
store.subscribe(render)
</code></pre>
<h2 id="展示和容器">展示和容器</h2>
<p>下面来介绍react-redux。前面的代码中，我们是通过store.subscribe()方法监控state状态的变化来更新UI层的。而使用react-redux，可以让组件动态订阅状态树。状态树一旦被修改，组件能自动刷新显示最新数据<br>
　react-redux将所有组件分成两大类：展示组件和容器组件。展示组件只负责UI呈现，所有数据由参数props提供；容器组件则负责管理数据和业务逻辑，带有内部状态，可使用redux的API。要使用react-redux，就要遵守它的组件拆分规范</p>
<h3 id="provider">【provider】</h3>
<p>react-redux提供Provider组件，可以让容器组件默认可以拿到state，而不用当容器组件层级很深时，一级级将state传下去<br>
将index.js文件更改如下</p>
<pre><code>// index.js
import React from 'react'
import ReactDOM from 'react-dom'
import store from './store'
import MathContainer from './container/MathContainer'
import { Provider } from 'react-redux'
ReactDOM.render(
  &lt;Provider store={store}&gt;
    &lt;MathContainer /&gt;
  &lt;/Provider&gt;,
  document.getElementById('root')
)
</code></pre>
<p>按照组件拆分规范，将原来index.js中相关代码，分拆到container/MathContainer和component/Math这两个组件中</p>
<h3 id="connect">【connect】</h3>
<p>react-redux提供connect方法，用于从展示组件生成容器组件。connect的意思就是将这两种组件连接起来</p>
<pre><code>import { connect } from 'react-redux'
const MathContainer = connect()(Math);
</code></pre>
<p>Math是展示组件，MathContainer就是由React-redux通过connect方法自动生成的容器组件<br>
　　为了定义业务逻辑，需要给出下面两方面的信息<br>
　　1、输入逻辑：外部的数据(即state对象)如何转换为展示组件的参数<br>
　　2、输出逻辑：用户发出的动作如何变为Action对象，从展示组件传出去<br>
　　因此，connect方法的完整API如下</p>
<pre><code>import {connect} from 'react-redux'
const MathContainer= connect(
    mapStateToProps,
    mapDispatchToProps
)(Math)
</code></pre>
<p>上面代码中，connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了展示组件的业务逻辑。前者负责输入逻辑，即将state映射到UI组件的参数(props)，后者负责输出逻辑，即将用户对展示组件的操作映射成Action</p>
<h3 id="mapstatetoprops">【mapStateToProps()】</h3>
<p>mapStateToProps建立一个从外部的state对象到展示组件的props对象的映射关系。作为参数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射</p>
<pre><code>const mapStateToProps = (state) =&gt; {
  return {
    num: getNum(state)                  
  }  
}
</code></pre>
<p>mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象。使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发展示组件重新渲染</p>
<pre><code>const mapStateToProps = (state,ownProps) =&gt; {
  return {
    num: getNum(state)                  
  }  
}
</code></pre>
<p>mapStateToProps会订阅Store，每当state更新的时候，就会自动执行，重新计算展示组件的参数，从而触发展示组件的重新渲染。connect方法可以省略mapStateToProps参数，那样，展示组件就不会订阅Store，就是说Store的更新不会引起展示组件的更新</p>
<h3 id="mapdispatchtoprops">【mapDispatchToProps】</h3>
<p>mapDispatchToProps是connect函数的第二个参数，用来建立展示组件的参数到store.dispatch方法的映射。也就是说，它定义了用户的哪些操作应该当作action，传给Store。它可以是一个函数，也可以是一个对象<br>
　　如果mapDispatchToProps是一个函数，会得到dispatch和ownProps(容器组件的props对象)两个参数</p>
<pre><code>const mapDispatchToProps = (dispatch,ownProps) =&gt; {
  return {
    onSetNumClick: () =&gt; dispatch(setNum())
  }
}
</code></pre>
<p>mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了展示组件的参数怎样发出action<br>
　　如果mapDispatchToProps是一个对象，它的每个键名也是对应展示组件的同名参数，键值应该是一个函数，会被当作action creator，返回的action会由redux自动发出<br>
　　因此，上面的写法简写如下所示</p>
<pre><code>const mapDispatchToProps = {
  onsetNumClick: () =&gt; setNum()
}
</code></pre>
<h3 id="components">【components】</h3>
<pre><code>// components/Math.js
import React from 'react'
const Math = ({
  num,
  isShow,
  fetchMessage,
  onSetNumClick,
  onAddOneClick,
  onAddTwoClick,
  onSqureClick
}) =&gt; (
  &lt;section&gt;
    &lt;p&gt;{num}&lt;/p&gt;
    &lt;input type=&quot;button&quot; onClick={onSetNumClick} value=&quot;设置Num&quot; /&gt;
    &lt;input type=&quot;button&quot; onClick={onAddOneClick} value=&quot;+1&quot; /&gt;
    &lt;input type=&quot;button&quot; onClick={onAddTwoClick} value=&quot;+2&quot; /&gt;
    &lt;input type=&quot;button&quot; onClick={onSqureClick} value=&quot;乘方&quot; /&gt;
    {isShow &amp;&amp; &lt;p&gt;{fetchMessage}&lt;/p&gt;}
  &lt;/section&gt;
)

export default Math

</code></pre>
<h3 id="containers">【containers】</h3>
<pre><code>        // containers/MathContainer.js
        import { connect } from 'react-redux'
        import Math from '../components/Math'
        import { getNum } from '../selectors/math'
        import { getFetchMessage, getFetchIsShow } from '../selectors/fetch'
        import { setNum, add, square } from '../actions/math'
        const mapStateToProps = state =&gt; {
        return {
            num: getNum(state),
            fetchMessage: getFetchMessage(state),
            isShow: getFetchIsShow(state)
        }
        }
        const mapDispatchToProps = {
        onSetNumClick: () =&gt; setNum(),
        onAddOneClick: () =&gt; add(1),
        onAddTwoClick: () =&gt; add(2),
        onSqureClick: () =&gt; square
        }
        const MathContainer = connect(mapStateToProps, mapDispatchToProps)(Math)
        export default MathContainer
</code></pre>
<h3 id="actions">【actions】</h3>
<pre><code>// actions/fetch.js
import { SET_FETCH_MESSAGE, HIDE_FETCH_MESSAGE } from '../constants/ActionTypes'
export const startFetch = { type: SET_FETCH_MESSAGE,message: '开始发送异步请求' }
export const successFetch = { type: SET_FETCH_MESSAGE, message: '成功接收数据' }
export const failFetch = { type: SET_FETCH_MESSAGE, message: '接收数据失败' }
export const hideFetchMessage = { type: HIDE_FETCH_MESSAGE }
</code></pre>
<pre><code>// actions/math.js
import { ADD, SQUARE, SET } from '../constants/ActionTypes'
import { startFetch, successFetch, failFetch, hideFetchMessage } from './fetch'
import axios from 'axios'
const uri = 'https://jsonplaceholder.typicode.com/posts/2'
export const add = num =&gt; ({ type: ADD, num })
export const square = { type: SQUARE }
export const setNum = () =&gt; (dispatch, getState) =&gt; {
  dispatch(startFetch)
  setTimeout(() =&gt; {dispatch(hideFetchMessage)}, 300)
  return axios
    .get(uri)
    .then(res =&gt; {
      dispatch(successFetch)
      setTimeout(() =&gt; {dispatch(hideFetchMessage)}, 300)
      dispatch({ type: SET, num: res.data.id })
    })
    .catch(err =&gt; {
      dispatch(failFetch)
      setTimeout(() =&gt; {dispatch(hideFetchMessage)}, 300)
    })
}
</code></pre>
<h3 id="constants">【constants】</h3>
<pre><code>// constants/ActionTypes.js
export const ADD = 'ADD'
export const SQUARE = 'SQUARE'
export const SET = 'SET'
export const SET_FETCH_MESSAGE = 'SET_FETCH_MESSAGE'
export const HIDE_FETCH_MESSAGE = 'HIDE_FETCH_MESSAGE'
</code></pre>
<h3 id="reducers">【reducers】</h3>
<pre><code>// reducers/fetch.js
import { SET_FETCH_MESSAGE,HIDE_FETCH_MESSAGE } from '../constants/ActionTypes'
const initState = {
  message:'',
  isShow:false
}
const fetch = (state = initState, action) =&gt; {
  switch (action.type) {
    case SET_FETCH_MESSAGE:
      return {isShow: true, message: action.message}
    case HIDE_FETCH_MESSAGE:
      return { isShow: false, message: '' }
    default:
      return state
  }
}
export default fetch
</code></pre>
<pre><code>// reducers/index.js
import { combineReducers } from 'redux'
import math from './math'
import fetch from './fetch'
const rootReducer = combineReducers({
  math,
  fetch
})

export default rootReducer
</code></pre>
<pre><code>import { ADD, SQUARE,SET } from '../constants/ActionTypes'
const math = (state = 10, action) =&gt; {
  switch (action.type) {
    case ADD:
      return state + action.num
    case SQUARE:
      return state * state
    case SET:
      return action.num
    default:
      return state
  }
}
export default math
</code></pre>
<h3 id="selectors">【selectors】</h3>
<pre><code>// selectors/fetch.js
export const getFetchMessage = state =&gt; state.fetch.message
export const getFetchIsShow = state =&gt; state.fetch.isShow
</code></pre>
<pre><code>// selectors/math.js
export const getNum = state =&gt; state.math
</code></pre>
<h3 id="根目录">【根目录】</h3>
<pre><code>// index.js
import React from 'react'
import ReactDOM from 'react-dom'
import store from './store'
import MathContainer from './containers/MathContainer'
import { Provider } from 'react-redux'
ReactDOM.render(
  &lt;Provider store={store}&gt;
    &lt;MathContainer /&gt;
  &lt;/Provider&gt;,
  document.getElementById('root')
)
</code></pre>
<pre><code>// store.js
import { createStore, applyMiddleware } from 'redux'
import thunk from 'redux-thunk'
import rootReducer from './reducers'
export default createStore(rootReducer,applyMiddleware(thunk))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[封装简易swiper]]></title>
        <id>https://django-lee-tony.github.io/post/feng-zhuang-jian-yi-swiper/</id>
        <link href="https://django-lee-tony.github.io/post/feng-zhuang-jian-yi-swiper/">
        </link>
        <updated>2021-02-05T13:04:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="因为项目中一些特殊的需求-需要一些特殊的swiper-在三方插件求而不得的情况下-不得已选择自己封装-基于css3属性-transition过度属性以及vue-transition组件封装">因为项目中一些特殊的需求 需要一些特殊的swiper 在三方插件求而不得的情况下 不得已选择自己封装  基于css3属性 transition过度属性以及vue transition组件封装</h2>
<h3 id="页面部分">页面部分</h3>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;div class=&quot;bwg-swiper&quot; @mouseenter=&quot;enterTarget&quot; @mouseleave=&quot;leaveTarget&quot;&gt;
            &lt;div class=&quot;swiper-slide&quot; v-for=&quot;(item,i) in list&quot; :key=&quot;i&quot;&gt;
                &lt;transition name=&quot;scaleToBig&quot;&gt;
                    &lt;div class=&quot;swiper-list&quot; v-if=&quot;index==i&quot;&gt;
                        &lt;img width=&quot;100%&quot; height=&quot;100%&quot; :src=&quot;item&quot; alt=&quot;&quot;&gt;
                    &lt;/div&gt;
                &lt;/transition&gt;
            &lt;/div&gt;
            &lt;div class=&quot;indicator-par &quot;&gt;
                &lt;div class=&quot;bwg-indicator indicator&quot; :class=&quot;{'bwg-indicator__active':index==i}&quot; @click=&quot;changIndex(i)&quot; v-for=&quot;(item,i) in list&quot; :key=&quot;i&quot;&gt;
&lt;!--                    显示的图片--&gt;
                    &lt;div class=&quot;show-img&quot;&gt;&lt;img :src=&quot;item&quot; alt=&quot;&quot;&gt;&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;transition enter-active-class=&quot;animated slideInLeft&quot; leave-active-class=&quot;animated slideOutLeft&quot;&gt;
                &lt;div class=&quot;bwg-prev bwg-swiper-push&quot; v-show=&quot;userEnter&quot; @click=&quot;editIndex('prev')&quot;&gt;〈&lt;/div&gt;
            &lt;/transition&gt;
            &lt;transition enter-active-class=&quot;animated slideInRight&quot; leave-active-class=&quot;animated slideOutRight&quot;&gt;
                &lt;div class=&quot;bwg-next bwg-swiper-push&quot; v-show=&quot;userEnter&quot; @click=&quot;editIndex('next')&quot;&gt;〉&lt;/div&gt;
            &lt;/transition&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h3 id="js部分">js部分</h3>
<pre><code>&lt;script&gt;

    export default {
        name:&quot;swiperCom&quot;,
        props:{
            autoplay:{
                type:Boolean,
                default:true
            },
            loop:{
                type:Boolean,
                default:true
            },
            delay:{
                type:Number,
                default:3000
            }
        },
        data() {
            return {
                timer:null,
                list:[
                ],
                index:0,
                userEnter:false
            };
        },
        mounted() {
          this.startMove()
        },
        methods:{
            //轮播开始计时
            startMove(){
                if(this.autoplay) { //是否自动轮播
                    if(this.timer) clearInterval(this.timer);
                    this.timer=setInterval(()=&gt;{
                        this.index++
                        if(this.index&gt;this.list.length-1){
                            this.index=0
                        }

                    },this.delay)
                }
            },
            //关闭计时器
            closeTimer(){
              if(this.timer){
                  clearInterval(this.timer)
              }
            },
            //鼠标划入
            enterTarget(){
                // console.log(1111);
                this.userEnter=true
               this.closeTimer()
            },
            //鼠标移出
            leaveTarget(){

                this.userEnter=false;
                this.startMove()
            },
            changIndex(i){
                this.index=i
            },
            editIndex(type){
                if(type=='prev'){
                   if(this.index&lt;=0){
                       this.index=this.list.length-1
                   }else{
                       this.index--
                   }
                }else{
                    if(this.index&gt;=this.list.length-1){
                        this.index=0
                    }else{
                        this.index++
                    }
                }
            }
        }
    }
&lt;/script&gt;
</code></pre>
<h3 id="style部分">style部分</h3>
<pre><code>&lt;style lang=&quot;scss&quot; scoped&gt;
    .bwg-swiper{
        height: 600px;
        width: 100%;
        min-width: $base-min-width;
        position: relative;
        z-index: 10;
        overflow: hidden;

        .swiper-slide{

            width: 1920px;
            margin: 0 auto;
            height: 100%;
            /*width: 100%;*/
            /*height: 100%;*/
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: 0;
            .swiper-list{
                width: 100%;
                height: 100%;
                position: absolute;
                left: 0;
                top: 0;
            }
        }
        .indicator-par{
            position: absolute;
            width: 100%;
            left: 0;
            bottom: 30px;
            z-index: 12;
            display: flex;
            justify-content: center;
            .indicator{
                position: relative;
                &amp;:hover{
                  .show-img{
                      display: block;
                  }
                }
               .show-img{
                   position: absolute;
                   width: 200px;
                   height: 50px;
                   border-radius: 5px;
                   box-shadow: 0px 0px 15px #00000029;
                   left: -90px;
                   top: -70px;
                   display: none;
                   overflow: hidden;
                   img{
                       width: 100%;
                       height: 100%;
                   }
               }
            }
        }
        .bwg-swiper-push{
            width: 40px;
            height: 80px;
            position: absolute;
            top: 220px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            color: #fff;
            background-color: #666;
            z-index: 13;
            cursor: pointer;
        }
        .bwg-prev{
            left: 0;
        }
        .bwg-next{
            right: 0;
        }
    }
&lt;/style&gt;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue webpack常规配置]]></title>
        <id>https://django-lee-tony.github.io/post/vue-webpack-chang-gui-pei-zhi/</id>
        <link href="https://django-lee-tony.github.io/post/vue-webpack-chang-gui-pei-zhi/">
        </link>
        <updated>2021-02-05T12:11:55.000Z</updated>
        <content type="html"><![CDATA[<h3 id="vueconfigjs">vue.config.js</h3>
<pre><code>const path = require('path')

function resolve(dir) {
    return path.join(__dirname, '.', dir)
}
module.exports={
    lintOnSave:false,
    productionSourceMap: process.env.NODE_ENV === 'development',
    devServer: {
        overlay: {
            warning: false,
            errors: false
        },
        open: true,
        proxy:{
            &quot;/api&quot;:{
                target: &quot;http://sp8001.sp.com:8888/&quot;,
            }
        }
    },
    css:{
        sourceMap:  process.env.NODE_ENV === 'development',// 开启 CSS source maps
        loaderOptions: {
            sass: {
                prependData: &quot;@import '~@/assets/style/public.scss';&quot;
            },
        }
    },
},
//合并配置
chainWebpack(config){
    config.plugins
            .delete('prefetch')
            .delete('preload')
        // 解决 cli3 热更新失效 https://github.com/vuejs/vue-cli/issues/1559
        config.resolve
            .symlinks(true)
    config.entry('main').add('babel-polyfill')
    // 开启图片压缩
        config.module.rule('images')
            .test(/\.(png|jpe?g|gif)(\?.*)?$/)
            .use('image-webpack-loader')
            .loader('image-webpack-loader')
            .options({ bypassOnDebug: true })
        if (process.env.NODE_ENV === 'production') {
            return {
                plugins: [
                    new CompressionPlugin({
                        test: /\.js$|\.ttf$|\.html$|\.css$|\.jpg$|\.jpeg$|\.png/, // 需要压缩的文件类型
                        threshold: 1024, // 归档需要进行压缩的文件大小最小值，我这个是10K以上的进行压缩
                        deleteOriginalAssets: false, // 是否删除原文件
                        minRatio: 0.8
                    })
                ]
            }
        }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react学习 生命周期]]></title>
        <id>https://django-lee-tony.github.io/post/react-xue-xi-sheng-ming-zhou-qi/</id>
        <link href="https://django-lee-tony.github.io/post/react-xue-xi-sheng-ming-zhou-qi/">
        </link>
        <updated>2021-02-05T09:46:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="react">React</h1>
<h2 id="组件生命周期">组件生命周期</h2>
<p>每一个组件都有几个可以重写以让代码在处理环节的特定时期运行的“生命周期方法”。方法中带有前缀 will 的在特定环节之前被调用，而带有前缀 did 的方法则会在特定环节之后被调用</p>
<h3 id="装配">【装配】</h3>
<p>这些方法会在组件实例被创建和插入DOM中时被调用：</p>
<pre><code class="language-$xslt">constructor()
static getDerivedStateFromProps()
componentWillMount()（版本17之后失效）
render()
componentDidMount()
</code></pre>
<h3 id="更新">【更新】</h3>
<p>属性或状态的改变会触发一次更新。当一个组件在被重渲时，这些方法将会被调用：</p>
<pre><code class="language-$xslt">componentWillReceiveProps()（版本17之后失效）
static getDerivedStateFromProps()
shouldComponentUpdate()
componentWillUpdate() （版本17之后失效）
render()
getSnapshotBeforeUpdate()
componentDidUpdate()
</code></pre>
<h3 id="卸载">【卸载】</h3>
<p>当一个组件被从DOM中移除时，该方法被调用：<br>
componentWillUnmount()</p>
<h3 id="错误处理">【错误处理】</h3>
<p>在渲染过程中发生错误时会被调用<br>
<code>componentDidCatch()</code></p>
<h2 id="装配过程">装配过程</h2>
<h3 id="render">【render()】</h3>
<p>render()函数应该纯净，意味着其不应该改变组件的状态，其每次调用都应返回相同的结果，同时不直接和浏览器交互。若需要和浏览器交互，将任务放在componentDidMount()阶段或其他的生命周期方法<br>
render 函数应该是一个纯函数，完全根据this.state和this.props来决定返回的结果，而且不要产生任何副作用。在render函数中调用this.setState毫无疑问是错误的，因为一个纯函数不应该引起状态的改变</p>
<h3 id="constructorprops">【constructor(props)】</h3>
<p>React组件的构造函数将会在装配之前被调用。当为一个React.Component子类定义构造函数时，应该在任何其他的表达式之前调用super(props)。否则，this.props在构造函数中将是未定义，并可能引发异常</p>
<h3 id="static-getderivedstatefrompropsnextprops-prevstate">【static getDerivedStateFromProps(nextProps, prevState)】</h3>
<pre><code>组件实例化后和接受新属性时将会调用getDerivedStateFromProps。它应该返回一个对象来更新状态，或者返回null来表明新属性不需要更新任何状态
</code></pre>
<p>[注意1]如果父组件导致了组件的重新渲染，即使属性没有更新，这一方法也会被调用<br>
　　[注意2]调用this.setState() 通常不会触发 getDerivedStateFromProps()<br>
典型用法如下所示：<br>
<code>static getDerivedStateFromProps() { return { indexOfShowControl: -1 } }</code></p>
<h3 id="componentdidmount">【componentDidMount()】</h3>
<pre><code>componentDidMount()在组件被装配后立即调用。初始化使得DOM节点应该进行到这里。若需要从远端加载数据，这是一个适合实现网络请求的地方
在这个方法中调用setState()将会触发一次额外的渲染，但是它将在浏览器刷新屏幕之前发生。这保证了即使render()将会调用两次，但用户不会看到中间状态。谨慎使用这一模式，因为它常导致性能问题
</code></pre>
<h2 id="更新及卸载">更新及卸载</h2>
<h3 id="shouldcomponentupdatenextprops-nextstate">【shouldComponentUpdate(nextProps, nextState)】</h3>
<pre><code>　使用shouldComponentUpdate()可以让React知道当前状态或属性的改变是否不影响组件的输出。默认行为是在每一次状态的改变重渲，在大部分情况下应该依赖于默认行为
当接收到新属性或状态时，shouldComponentUpdate() 在渲染前被调用。默认为true
若该方法返回false，则componentWillUpdate()、componentDidUpdate()、render()将不会被调用
*** [注意]该方法并不会在初始化渲染或当使用forceUpdate()时被调用
</code></pre>
<h3 id="getsnapshotbeforeupdate">【getSnapshotBeforeUpdate()】</h3>
<pre><code>getSnapshotBeforeUpdate()在最新的渲染输出提交给DOM前将会立即调用。它让组件能去获得当前的值在它们可能要改变前。这一生命周期返回的任何值将会作为参数被传递给componentDidUpdate()
[注意]该方法必须与componentDidUpdate()方法一起使用
</code></pre>
<h3 id="componentdidupateprevprops-prevstate">【componentDidUpate(prevProps, prevState)】</h3>
<pre><code>componentDidUpdate()会在更新发生后立即被调用。该方法并不会在初始化渲染时调用。当组件被更新时，使用该方法是操作DOM的一次机会。这也是一个适合发送请求的地方
</code></pre>
<h3 id="componentwillunmount">【componentWillUnmount()】</h3>
<pre><code>componentWillUnmount()在组件被卸载和销毁之前立刻调用。可以在该方法里处理任何必要的清理工作，例如解绑定时器，取消网络请求，清理任何在componentDidMount环节创建的DOM元素
</code></pre>
<h2 id="强制渲染">强制渲染</h2>
<h3 id="componentforceupdatecallback">【component.forceUpdate(callback)】</h3>
<pre><code>　默认情况，当组件或状态发生改变，组件将会重渲。若render()方法依赖其他数据，可以通过调用forceUpdate()来告诉React组件需要重渲
调用forceUpdate()将会导致组件的 render()方法被调用，并忽略shouldComponentUpdate()。这将会触发每一个子组件的生命周期方法，涵盖每个子组件的shouldComponentUpdate() 方法。若当标签改变，React仅会更新DOM
通常应该尝试避免所有forceUpdate() 的用法并仅在render()函数里从this.props和this.state读取数据
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[create-project-of-vue2]]></title>
        <id>https://django-lee-tony.github.io/post/create-project-of-vue2/</id>
        <link href="https://django-lee-tony.github.io/post/create-project-of-vue2/">
        </link>
        <updated>2021-02-05T09:46:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="安装">安装</h1>
<h2 id="卸载旧版本">卸载旧版本：</h2>
<h3 id="如果你之前都是基于vue-cli2x你需要先卸载它">如果你之前都是基于vue-cli2.X,你需要先卸载它：</h3>
<pre><code>#卸载vue-cli 老版本的cli
npm uninstall -g vue-cli
</code></pre>
<h2 id="安装-2">安装</h2>
<pre><code>npm install -g @vue/cli  // 安装cli3.x
vue --version 或者 vue -V  //查看版本是否为3.x
</code></pre>
<h1 id="创建项目">创建项目</h1>
<pre><code class="language-$xslt">vue create my-project // 其中my-project为项目目录名称
</code></pre>
<h3 id="此处有两个选择">此处有两个选择：</h3>
<pre><code class="language-$xslt">default (babel, eslint) 默认配置 提供babel和eslint支持
Manually select features 自己手动去选择需要的配置
</code></pre>
<h3 id="选择手动后">选择手动后</h3>
<pre><code class="language-$xslt">对于每一项的功能，做一下简单阐述：
Babel 主要是对es6语法转换成兼容的js （选上）
TypeScript 支持使用TypeScript语法来编写代码
PWA PWA 支持
Router 支持vue路由配置插件（一般都会选择）
Vuex 支持vue程序状态管理模式 (一般都会选择)
CSS Pre-processors 支持css预处理器 （一般都会选择）
Linter / Formatter 支持代码风格检查和格式化 （选上）
Unit Testing 单元测试
E2E Testing E2E测试
</code></pre>
<h3 id="当我们需要自定义webpack相关配置的时候需要在项目根目录中创建vueconfigjs文件它会被vuecli-server自动加载相关配置内容官网将的很详细">当我们需要自定义webpack相关配置的时候需要在项目根目录中创建vue.config.js文件，它会被@vue/cli-server自动加载，相关配置内容官网将的很详细</h3>
<pre><code class="language-$xslt">当我们需要调整webpac k配置的时候，
可以通过chainWebpack属性进行链式操作，
这里有个技巧就是通过 vue inspect --mode production product.js 
或vue inspect &gt; development.js 
来导处生产和开发环境的配置文件，文件里面包含了链式访问的规则，
这样我们就可以通过链式操作来修改添加webpack配置。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[svg正确使用方式]]></title>
        <id>https://django-lee-tony.github.io/post/svg-zheng-que-shi-yong-fang-shi/</id>
        <link href="https://django-lee-tony.github.io/post/svg-zheng-que-shi-yong-fang-shi/">
        </link>
        <updated>2021-02-05T09:45:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="svg正确使用方式">svg正确使用方式</h1>
<h2 id="svg-sprite-loader-下载">svg-sprite-loader 下载</h2>
<pre><code class="language-$xslt">npm i svg-sprite-loader 或者 yarn add svg-sprite-loader
</code></pre>
<h2 id="新建vueconfigjs-创建srcassetssvg-文件夹-将svg放入该文件夹中">新建vue.config.js 创建src/assets/svg 文件夹  将svg放入该文件夹中</h2>
<pre><code class="language-$xslt">const path = require(&quot;path&quot;);
function resolve(dir) {
    return path.join(__dirname, &quot;.&quot;, dir);
}
module.exports={
    ...
    chainwebpack:config =&gt;{
        ...
    config.module.rules.delete(&quot;svg&quot;); //重点:删除默认配置中处理svg,
            //const svgRule = config.module.rule('svg')
            //svgRule.uses.clear()
            config.module
                .rule(&quot;svg-sprite-loader&quot;)
                .test(/\.svg$/)
                .include.add(resolve(&quot;src/assets/svg&quot;)) //处理svg目录
                .end()
                .use(&quot;svg-sprite-loader&quot;)
                .loader(&quot;svg-sprite-loader&quot;)
                .options({
                    symbolId: &quot;icon-[name]&quot;
                });
    }
}
</code></pre>
<h2 id="封装组件">封装组件</h2>
<h3 id="新建indexvue">新建index.vue</h3>
<pre><code class="language-$xslt">//index.vue
&lt;template&gt;
    &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot;&gt;
        &lt;use :xlink:href=&quot;iconName&quot;/&gt;
    &lt;/svg&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        name: 'SvgIcon',
        props: {
            iconClass: { //接收svg名称 注意就是svg文件名
                type: String,
                required: true
            },
            className: { //svg图标的属性 如通过font-sizee属性控制icon大小
                type: String,
                default: ''
            }
        },
        computed: {
            iconName() {
                return `#icon-${this.iconClass}`
            },
            svgClass() {
                if (this.className) {
                    return 'svg-icon ' + this.className
                } else {
                    return 'svg-icon'
                }
            }
        }
    }
&lt;/script&gt;
&lt;style scoped&gt;
    .svg-icon {
        width: 1em;
        height: 1em;
        vertical-align: -0.15em;
        fill: currentColor;
        overflow: hidden;
    }
&lt;/style&gt;

</code></pre>
<h3 id="indexjs文件">index.js文件</h3>
<pre><code class="language-$xslt">//使用webpack提供的 require.context方法 引入所有的svg
import svgIcon from &quot;./index.vue&quot;
const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)
const req = require.context('../../assets/svg', false, /\.svg$/)
requireAll(req)
// 暴露方法
export default {
    install(Vue){
        Vue.component('svgIcon',svgIcon);
    }
}
</code></pre>
<h2 id="使用方式">使用方式</h2>
<pre><code class="language-$xslt"> &lt;svg-icon  icon-class=&quot;svgname&quot; class-name=&quot;svgclass&quot;&gt;&lt;/svg-icon&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue封装message组件]]></title>
        <id>https://django-lee-tony.github.io/post/vue-feng-zhuang-message-zu-jian/</id>
        <link href="https://django-lee-tony.github.io/post/vue-feng-zhuang-message-zu-jian/">
        </link>
        <updated>2021-02-05T09:45:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基于-element-源码改造-再封装">基于 element 源码改造 再封装</h1>
<h2 id="先封装-vue部分">先封装 .vue部分</h2>
<pre><code class="language-$xslt">&lt;template&gt;
  &lt;transition name=&quot;el-message-fade&quot; @after-leave=&quot;handleAfterLeave&quot;&gt;
    &lt;div
      :class=&quot;[
        'bwg-message',
        type &amp;&amp; !iconClass ? `white-${type}` : '',
        center ? 'is-center' : '',
        showClose ? 'is-closable' : '',
        customClass
      ]&quot;
      :style=&quot;positionStyle&quot;
      v-show=&quot;visible&quot;
      @mouseenter=&quot;clearTimer&quot;
      @mouseleave=&quot;startTimer&quot;
      role=&quot;alert&quot;
    &gt;
      &lt;div&gt;
&lt;!--        &lt;i :class=&quot;iconClass&quot; v-if=&quot;iconClass&quot;&gt;&lt;/i&gt;--&gt;
&lt;!--        &lt;i :class=&quot;typeClass&quot; v-else&gt;&lt;/i&gt;--&gt;
        &lt;svg-icon :iconClass=&quot;svgName&quot; className=&quot;message-alert&quot;&gt;&lt;/svg-icon&gt;
      &lt;/div&gt;

      &lt;slot&gt;
        &lt;p v-if=&quot;!dangerouslyUseHTMLString&quot; class=&quot;el-message__content&quot;&gt;
          {{ message }}
        &lt;/p&gt;
        &lt;p v-else v-html=&quot;message&quot; class=&quot;el-message__content&quot;&gt;&lt;/p&gt;
      &lt;/slot&gt;
      &lt;i
        v-if=&quot;showClose&quot;
        class=&quot;el-message__closeBtn el-icon-close&quot;
        @click=&quot;close&quot;
      &gt;&lt;/i&gt;
    &lt;/div&gt;
  &lt;/transition&gt;
&lt;/template&gt;
&lt;script type=&quot;text/babel&quot;&gt;
const typeMap = {
  success: &quot;success&quot;,
  info: &quot;info&quot;,
  warning: &quot;warning&quot;,
  error: &quot;error&quot;
};
export default {
  data() {
    return {
      visible: false,
      message: &quot;&quot;,
      duration: 1000,
      type: &quot;info&quot;,
      iconClass: &quot;&quot;,
      customClass: &quot;&quot;,
      onClose: null,
      showClose: false,
      closed: false,
      verticalOffset: 20,
      timer: null,
      dangerouslyUseHTMLString: false,
      center: false
    };
  },
  computed: {
    typeClass() {
      return this.type &amp;&amp; !this.iconClass
        ? `white--i-success el-icon-${typeMap[this.type]}`
        : &quot;&quot;;
    },
      //返回svg名称
      svgName(){
        if(this.type){
            return this.type
        }else{
            return &quot;success&quot;
        }
      },
    positionStyle() {
      return {
        top: `${this.verticalOffset}px`
      };
    }
  },
  watch: {
    closed(newVal) {
      if (newVal) {
        this.visible = false;
      }
    }
  },
  methods: {
    handleAfterLeave() {
      this.$destroy(true);
      this.$el.parentNode.removeChild(this.$el);
    },
    close() {
      this.closed = true;
      if (typeof this.onClose === &quot;function&quot;) {
        this.onClose(this);
      }
    },
    clearTimer() {
      clearTimeout(this.timer);
    },
    startTimer() {
      if (this.duration &gt; 0) {
        this.timer = setTimeout(() =&gt; {
          if (!this.closed) {
            this.close();
          }
        }, this.duration);
      }
    },
    keydown(e) {
      if (e.keyCode === 27) {
        // esc关闭消息
        if (!this.closed) {
          this.close();
        }
      }
    }
  },
  mounted() {
    this.startTimer();
    document.addEventListener(&quot;keydown&quot;, this.keydown);
  },
  beforeDestroy() {
    document.removeEventListener(&quot;keydown&quot;, this.keydown);
  }
};
&lt;/script&gt;
</code></pre>
<p>##封装.js部分</p>
<pre><code class="language-$xslt">import Vue from &quot;vue&quot;;
import Main from &quot;./main.vue&quot;;
// import { PopupManager } from 'element-ui/src/utils/popup';
// import { isVNode } from 'element-ui/src/utils/vdom';
const hasOwnProperty = Object.prototype.hasOwnProperty;

export function noop() {}

export function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
function isVNode(node) {
  return (
    node !== null &amp;&amp;
    typeof node === &quot;object&quot; &amp;&amp;
    hasOwn(node, &quot;componentOptions&quot;)
  );
}
let MessageConstructor = Vue.extend(Main);
let instance;
let instances = [];
let seed = 1;
const Message = function(options) {
  if (Vue.prototype.$isServer) return;
  options = options || {};
  if (typeof options === &quot;string&quot;) {
    options = {
      message: options
    };
  }
  let userOnClose = options.onClose;
  let id = &quot;message_&quot; + seed++;
  options.onClose = function() {
    Message.close(id, userOnClose);
  };
  instance = new MessageConstructor({
    data: options
  });
  instance.id = id;
  if (isVNode(instance.message)) {
    instance.$slots.default = [instance.message];
    instance.message = null;
  }
  instance.$mount();
  document.body.appendChild(instance.$el);
  let verticalOffset = options.offset || 20;
  instances.forEach(item =&gt; {
    verticalOffset += item.$el.offsetHeight + 16;
  });
  instance.verticalOffset = verticalOffset;
  instance.visible = true;
  instance.$el.style.zIndex = 10;
  instances.push(instance);
  return instance;
};
[&quot;success&quot;, &quot;warning&quot;, &quot;info&quot;, &quot;error&quot;].forEach(type =&gt; {
  Message[type] = options =&gt; {
    if (typeof options === &quot;string&quot;) {
      options = {
        message: options
      };
    }
    options.type = type;
    return Message(options);
  };
});
Message.close = function(id, userOnClose) {
  let len = instances.length;
  let index = -1;
  let removedHeight;
  for (let i = 0; i &lt; len; i++) {
    if (id === instances[i].id) {
      removedHeight = instances[i].$el.offsetHeight;
      index = i;
      if (typeof userOnClose === &quot;function&quot;) {
        userOnClose(instances[i]);
      }
      instances.splice(i, 1);
      break;
    }
  }
  if (len &lt;= 1 || index === -1 || index &gt; instances.length - 1) return;
  for (let i = index; i &lt; len - 1; i++) {
    let dom = instances[i].$el;
    dom.style[&quot;top&quot;] =
      parseInt(dom.style[&quot;top&quot;], 10) - removedHeight - 16 + &quot;px&quot;;
  }
};
Message.closeAll = function() {
  for (let i = instances.length - 1; i &gt;= 0; i--) {
    instances[i].close();
  }
};
export default Message;
</code></pre>
<p>##最后在需要调用的地方 引入即可  使用方式与element message类似</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[websocket封装在vuex中]]></title>
        <id>https://django-lee-tony.github.io/post/websocket-feng-zhuang-zai-vuex-zhong/</id>
        <link href="https://django-lee-tony.github.io/post/websocket-feng-zhuang-zai-vuex-zhong/">
        </link>
        <updated>2021-02-05T09:44:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="websocket封装暴露方法给vuex调用">websocket封装暴露方法给vuex调用</h1>
<h2 id="在vuex创建一个socket模块-用于连接以及接收消息">在vuex创建一个socket模块 用于连接以及接收消息</h2>
<pre><code class="language-$xslt">//socket.js
let timer,timer1;
import router from &quot;../../router&quot;;
import Socket from &quot;../../utils/socket&quot;;
    export default {
        state: {
            ws: null, // websorket实例
            wsAddress:null,//websocket地址
            visible:false,//页面弹窗显隐状态值
            acceptMessage:{},//接收的信息
        },
        mutations: {
            /**
             * 将socket赋值给ws 方便在组件中调用
             */
            CONTACT_SOCKET (state, { commit,dispatch }) {
                // let p=new Socket(commit,null,state.wsAddress)
                state.ws = new Socket(commit,dispatch,state.wsAddress?state.wsAddress:null);

            },
            /**
             * 接收消息
             */
            ACCEPT_MESSAGE(state,data){
                state.acceptMessage=data;
            },
            /**
             * 获取到init接口中的ws地址后 再将socket初始化连接
             */
            INSERT_SOCKET(state,val){
                if(val.value){
                    state.wsAddress=val.value
                }
            },
            /**
             * 关闭socket 在退出登录时触发
             */
            CLOSE_SOCKET(state){
                if(state.ws){
                    state.ws.$soctket_close();
                    state.ws=null
                }

                    // console.log(state.ws);
            },
            /**
             * 控制弹框的状态值
             */
            OPEN_DIALOG(state,flag){
                if(timer) clearTimeout(timer)
                if(flag){
                    timer=setTimeout(()=&gt;{
                        state.visible=false
                    },3000)
                }
                state.visible=flag
            },
        },
        actions: {
            /**
             * 请求得到ws地址后存入state
             */
            SOCKET_INIT ({commit, state},val) {
                commit('INSERT_SOCKET',val)//存入ws地址
            },
            /**
             * 初始化链接socket
             */
            CONTACT_SOCKET({dispatch,commit}){
                commit('CONTACT_SOCKET', { commit ,dispatch}) //把commit作为参数
            },
            /**
             * 接收消息
             */
            ['ACCEPT_MESSAGE']({dispatch,commit},data){
                let message=JSON.parse(data);
                let {action}=message;
                if(action==='KEEP_ALIVE') return ;
              
            }
        }
    }
</code></pre>
<h2 id="封装websocket">封装websocket</h2>
<pre><code class="language-$xslt">//utils/socket.js
/*
* socket长连接和公共管理方案
* websocket和 VueX 还有 Redux建立起长连接机制 ，防止在路由切换时候的时候断开连接，需要把socket实例放入公共管理统一处理
* 此方案暴露出一个触发器  api,方便任何组件调用 , 内部有一个订阅器api ，与 VueX 中 mutations
*/
import {getToken} from &quot;./permission&quot;;

let socketUrl = ''
/**
 * @param value
 * @returns {string}  强数据类型校验
 */

function isType (value) {
    return Object.prototype.toString.call(value).slice(8, -1)
}

/**
 * @param event 当前事件
 *  事件轮询器
 */
function eventPoll (event, outerConditon, time, callback) {
    let timer
    let currentCondition
    timer = clearInterval(() =&gt; {
        if (currentCondition === outerConditon) {
            clearInterval(timer)
            callback &amp;&amp; callback()
        }
        currentCondition = event()
    }, time)
}

function isSocketContent () {
    if (process.env.NODE_ENV === 'development') {
        socketUrl = 'ws://192.168.1.159:8088/ws'
    }
    else {
        socketUrl = 'wss://192.168.12.50:3333'
    }
}

/**
 * @constructor 构造函数
 * commit 公共管理触发器
 * action dispatch
 */

function socket (commit, actions,wsAddress) {
    if (isType(commit) !== 'Function') {
        throw new Error('commit must be a function')
    }
    this.wsAddress=wsAddress //socket地址
    this.commit = commit
    this.actions = actions || null
    this.timer = null
    this.errorResetNumber = 0 // 错误重连间隔
    this.closeWs = false
    this.errorFrom = 0 // socket断开来源
    this.errorResetTimer = null // 错误重连轮询
    this.errorDispatchOpen = true // 开启错误调度
    this.heartSocketOpen = false
    this.retry=0
    // isSocketContent()
    this.$soctket_init();

}
socket.prototype.$soctket_init = function (callback) {
    const _this = this
    if (_this.closeWs) {
        throw new Error('socket is closed ,$socker_init is fail ,  all methods is invalid')
    }
    const token = getToken()
    // const token=&quot;eyJhbGciOiJIUzI1NiJ9.eyJ3ZWJSb2xlIjoiYWRtaW4iLCJpZCI6IjMiLCJ1c2VybmFtZSI6ImJvc3MwMDIiLCJqdGkiOiIyZWUxM2I1ZWExNzU0NGUyYWZmOWJiNmRkMzc5NGVjYiIsInN1YiI6IlhCU3BvcnRzIiwiaWF0IjoxNjA4MTkwNzAzLCJleHAiOjE2NDA3Nzc5MDN9.UfuslVrqjGMOhdiIGqBhTW45mPOt_xaECGsBM7igvSM&amp;device=d&amp;retry=0&quot;
    // if (!token) {
    //     throw new Error('token  is undefined')
    // }
    const handerErrorMachine = () =&gt; {
        if (_this.errorResetNumber === 20) {
            _this.errorResetNumber = 0
            _this.errorResetTimer = null
            _this.errorFrom = 0
            _this.errorDispatchOpen = false
            _this.ws = null
            location.reload()
            // console.log('socket连接失败')
            return
        }
        _this.errorResetTimer = setTimeout(() =&gt; {
            _this.$soctket_init()
            _this.errorResetNumber++
        }, _this.errorResetNumber * 10000)
    }
    /**
     * 连接错误或者断开乱接
     * eventment 1 关闭 2连接错误
     */
    const errorDispatch = (eventment) =&gt; {
        let event = eventment
        return function () {
            if (_this.errorFrom === 0 &amp;&amp; _this.errorDispatchOpen) {
                _this.errorFrom = event
            }
            event === 1 ? console.log('web socket has failed  from closeState ') : console.log('web socket has failed  from errorState ')
            if (_this.errorFrom === event &amp;&amp; !_this.closeWs) {
                _this.errorResetTimer &amp;&amp; clearTimeout(_this.errorResetTimer)
                handerErrorMachine()
            }
        }
    }
    if (this.timer) clearTimeout(this.timer)
    //${this.wsAddress}ws://192.168.1.250:8088/ws
    _this.ws = new WebSocket(`${this.wsAddress}?token=${token}&amp;device=m&amp;retry=${_this.retry}`);
    _this.ws.onopen = function () {
        callback &amp;&amp; callback();
        _this.retry=1
        _this.errorResetNumber = 0
        _this.errorResetTimer = null
        _this.errorFrom = 0
        _this.errorDispatchOpen = true
        _this.$soctket_subscribe()
        _this.$soctket_heartSoctket()
        console.log('web socket has connected ')
    }

    _this.ws.onclose = errorDispatch(1);
    // _this.ws.onerror = errorDispatch(2)
}

/**
 * 触发器-&gt;发布信息
 * @param callback 状态处理
 * @param value 数据处理
 */
socket.prototype.$soctket_emit = function (value, callback) {
    const _this = this
    const poll = function () {
        return _this.ws.readyState
    }
    if (callback &amp;&amp; isType(callback) !== 'Function') {
        throw new Error('$socket_emit arugment[1] must be a function')
    }
    if (!_this.ws) {
        throw new Error('$socket dispatch is fail please use $socket_open method')
    }
    if (_this.ws.readyState === 1) { // 连接成功状态
        _this.ws.send(value)
        _this.$soctket_heartSoctket()
        callback &amp;&amp; callback()
    }
    else if (_this.ws.readyState === 0) { // 连接中状态 ，轮询查询连接
        eventPoll(poll, 1, 500, () =&gt; {
            _this.ws.send(value)
            _this.$soctket_heartSoctket()
            callback &amp;&amp; callback()
        })
    }
    else { // 失败重新连接
        _this.$soctket_init(() =&gt; {
            _this.$soctket_emit(value, callback)
        })
    }
}
/**
 * 订阅器-&gt;接受广播
 */
socket.prototype.$soctket_subscribe = function () {
    const _this = this
    _this.ws.onmessage = function (res) {
        // console.log(res.data);
        if (_this.actions) {
            if (isType(_this.actions) !== 'Function') {
                throw new Error('actions')
            } else {
                _this.actions('ACCEPT_MESSAGE',res.data)
            }
        } else {
            _this.commit('ACCEPT_MESSAGE',res.data);

        }
        // _this.$soctket_heartSoctket();
    }
}
/**
 * 发送心跳
 * 心脏搏动机制-&gt;防止断开连接
 */

socket.prototype.$soctket_heartSoctket = function () {
    if (this.timer) clearTimeout(this.timer)
    // console.log(this.timer)
    this.timer = setTimeout(() =&gt; {
        if (this.ws.readyState === 1 || this.ws.readyState === 0) {
            this.ws.send(JSON.stringify({ &quot;action&quot; : &quot;KEEP_ALIVE&quot;}))
            this.$soctket_heartSoctket()
        } else {
            this.$soctket_init()
        }
    }, 30000)
}
/**
 * 关闭socket连接
 */
socket.prototype.$soctket_close = function () {
    console.log(&quot;close&quot;);
    if (this.timer) clearTimeout(this.timer)
    if (this.errorResetTimer)clearTimeout(this.errorResetTimer)
    this.closeWs = true
    this.retry=0
    this.ws.close()
}
/**
 * 重启socket连接
 */
socket.prototype.$soctket_open = function () {
    if (!this.closeWs) {
        throw new Error('socket is connected')
    }
    this.timer = null
    this.errorResetNumber = 0
    this.closeWs = false
    this.errorFrom = 0
    this.errorResetTimer = null
    this.errorDispatchOpen = true
    this.heartSocketOpen = false
    this.closeWs = false
    this.$soctket_init()
}
export default socket


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vux多模块应用]]></title>
        <id>https://django-lee-tony.github.io/post/vux-duo-mo-kuai-ying-yong/</id>
        <link href="https://django-lee-tony.github.io/post/vux-duo-mo-kuai-ying-yong/">
        </link>
        <updated>2021-02-05T09:44:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vuex多模块使用方式">vuex多模块使用方式</h1>
<h2 id="下载">下载</h2>
<pre><code class="language-$xslt">npm i vuex 或者 yarn add vuex
</code></pre>
<p>##应用<br>
在vue项目中 src 目录下创建store文件夹<br>
创建index.js文件 创建modules文件夹 项目中分出的模块放入此文件夹中</p>
<pre><code class="language-$xslt">import Vue from 'vue';
import Vuex from 'vuex';
Vue.use(Vuex);
/**
 * 配置多模块
 */
const files = require.context(&quot;./modules&quot;, false, /\.js$/);
const modules = {};
files.keys().forEach(key =&gt; {
  modules[key.replace(/(\.\/|\.js)/g, &quot;&quot;)] = files(key).default;
});
Object.keys(modules).forEach((key) =&gt; {
  modules[key][&quot;namespaced&quot;] = true;
});
export default new Vuex.Store({
  modules
})
</code></pre>
<h3 id="vuex提供的辅助函数">vuex提供的辅助函数</h3>
<pre><code class="language-$xslt">mapActions 触发action 
mapMutations 触发mutations
mapState 获取state中的值
mapGetters 获取getter 
</code></pre>
<h3 id="项目中使用">项目中使用</h3>
<pre><code class="language-$xslt">//.vue
    methods中触发
    ...mapActions(模块名,触发的actions方法)
    ...mapMutations(模块名,触发的mutations名)
    computed中触发
    ...mapState(模块名,获取的value)
//.js 在vuex模块中
    actions
    ['方法名 建议使用常量']({dispatch,commit,rootState}){
        dispatch(方法名,数据) //触发actions
        dispatch(模块名/方法名,数据,{root:true}) //触发其他模块的actions
        commit(方法名,数据) 触发mutations
        //触发其他模块的mutations同理actions
        rootState 可以获取其他模块的state value
    } //
    commit 
    ['方法名 建议使用常量'](state,data){} //state value修改
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue项目修改ico]]></title>
        <id>https://django-lee-tony.github.io/post/vue-xiang-mu-xiu-gai-ico/</id>
        <link href="https://django-lee-tony.github.io/post/vue-xiang-mu-xiu-gai-ico/">
        </link>
        <updated>2021-02-05T09:43:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="ico-修改基于vue-cli3">ico 修改基于vue-cli3</h1>
<h3 id="在开发vue项目的时候-经常会出现ico修改失败-于是网上搜索了一堆的解决方案">在开发vue项目的时候 经常会出现ico修改失败 于是网上搜索了一堆的解决方案</h3>
<pre><code class="language-$xslt">
1 , &lt;link rel=&quot;icon&quot; href=&quot;./icon.ico&quot;&gt; //手动更改 开发和生产都无效
2,通过在 vue.config.js 手动设置pwa 无效
    pwa:{
        iconPaths:{
            ....
        }
    }
3,通过js动态去设置 无效
    (()=&gt;{
      var link = document.querySelector(&quot;link[rel*='manifest']&quot;);
        link.rel=&quot;ico&quot;
        link.href=&quot;图片路径&quot;
      document.getElementsByTagName('head')[0].appendChild(main);
    })() 
4,手动强制修改 &lt;link rel=&quot;icon&quot;  href=&quot;./img/&lt;%= VUE_APP_NODE %&gt;.ico&quot; type=&quot;image/x-icon&quot; /&gt; 无效
 最后直接删除public下的img 文件夹  虽然生效 但是页面会报错   崩溃
</code></pre>
<h2 id="生效的解决方案">生效的解决方案</h2>
<pre><code class="language-$xslt">1,
    手动删除 public/img文件夹
//解决页面报错
        (()=&gt;{
          var main = document.querySelector(&quot;link[rel*='manifest']&quot;);
          document.getElementsByTagName('head')[0].removeChild(main);
        })();
    //然后再手动设置
    &lt;link rel=&quot;icon&quot;  href=&quot;./img/&lt;%= VUE_APP_NODE %&gt;.ico&quot; type=&quot;image/x-icon&quot; /&gt;
此时刷新页面 生效并且无报错
2,通过再vue.config.js中设置 动态加入到 htmlWebpackPlugin中
 chainWebpack: config =&gt; {
        config.plugin('html').tap((options) =&gt; {
            options[0].title= process.env.VUE_APP_TITLE//设置项目名称
            // options[0].favicon='public/img/rora.ico' //设置ico
            // options[0].BASE_URL= &quot;./favicon/&quot; //设置relicon
            // options[0].BASE_URL_VARIABLE= process.env.VUE_APP_VARIABLE //设置relicon
            return options
        })
    }
    然后可以直接在index.html中使用 
    &lt;link rel=&quot;icon&quot;  href=&quot;&lt;%=  htmlWebpackPlugin.options.favicon %&gt;&quot; type=&quot;image/x-icon&quot; /&gt;
    此方法生效 
</code></pre>
]]></content>
    </entry>
</feed>