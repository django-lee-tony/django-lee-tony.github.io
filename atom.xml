<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://django-lee-tony.github.io</id>
    <title>django </title>
    <updated>2021-02-24T06:36:49.338Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://django-lee-tony.github.io"/>
    <link rel="self" href="https://django-lee-tony.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://django-lee-tony.github.io/images/avatar.png</logo>
    <icon>https://django-lee-tony.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, django </rights>
    <entry>
        <title type="html"><![CDATA[ES6之Proxy]]></title>
        <id>https://django-lee-tony.github.io/post/es6-zhi-proxy/</id>
        <link href="https://django-lee-tony.github.io/post/es6-zhi-proxy/">
        </link>
        <updated>2021-02-24T05:12:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="proxy-介绍">Proxy 介绍</h1>
<p>使用Proxy，你可以将一只猫伪装成一只老虎。下面大约有6个例子，我希望它们能让你相信，Proxy 提供了强大的 Javascript 元编程。<br>
Proxy用于修改某些操作的默认行为，也可以理解为在目标对象之前架设一层拦截，外部所有的访问都必须先通过这层拦截，因此提供了一种机制，可以对外部的访问进行过滤和修改。这个词的原理为代理，在这里可以表示由它来“代理”某些操作，译为“代理器”。<br>
ES6原生提供了Proxy构造函数，用来生成Proxy实例。<br>
<code>var proxy = new Proxy(target, handler);</code><br>
Proxy对象的所有用法，都是上面的这种形式。不同的只是handle参数的写法。其中new Proxy用来生成Proxy实例，target是表示所要拦截的对象，handle是用来定制拦截行为的对象。<br>
下面是 Proxy 最简单的例子是，这是一个有陷阱的代理，一个get陷阱，总是返回42。</p>
<pre><code>let target = {
    x: 10,
    y: 20
};
​
let hanler = {
    get: (obj, prop) =&gt; 42
};
​
target = new Proxy(target, hanler);
​
target.x; //42
target.y; //42
target.x; // 42
结果是一个对象将为任何属性访问操作都返回“42”。 这包括target.x，target['x']，Reflect.get(target, 'x')等。
</code></pre>
<p>但是，Proxy 陷阱当然不限于属性的读取。 它只是十几个不同陷阱中的一个：</p>
<pre><code>handler.get
handler.set
handler.has
handler.apply
handler.construct
handler.ownKeys
handler.deleteProperty
handler.defineProperty
handler.isExtensible
handler.preventExtensions
handler.getPrototypeOf
handler.setPrototypeOf
handler.getOwnPropertyDescriptor

</code></pre>
<h1 id="proxy-用例">Proxy 用例</h1>
<figure data-type="image" tabindex="1"><img src="https://django-lee-tony.github.io/post-images/1614147719737.jpg" alt="" loading="lazy"></figure>
<h2 id="默认值零值">默认值/“零值”</h2>
<p>在 Go 语言中，有零值的概念，零值是特定于类型的隐式默认结构值。其思想是提供类型安全的默认基元值，或者用gopher的话说，给结构一个有用的零值。</p>
<p>虽然不同的创建模式支持类似的功能，但Javascript无法用隐式初始值包装对象。Javascript中未设置属性的默认值是undefined。但 Proxy 可以改变这种情况。</p>
<pre><code>const withZeroValue = (target, zeroValue) =&gt;
    new Proxy(target, {
        get: (obj, prop) =&gt; (prop in obj ? obj[prop] : zeroValue)
    });
    函数withZeroValue 用来包装目标对象。 如果设置了属性，则返回属性值。 否则，它返回一个默认的“零值”。
    从技术上讲，这种方法也不是隐含的，但如果我们扩展withZeroValue，以Boolean (false), Number (0), String (&quot;&quot;), Object ({})，Array ([])等对应的零值，则可能是隐含的。
    let pos = {
    x: 4,
    y: 19
};
console.log(pos.x, pos.y, pos.z); // 4, 19, undefined
pos = withZeroValue(pos, 0);
console.log(pos.z, pos.y, pos.z); // 4, 19, 0
</code></pre>
<p>此功能可能有用的一个地方是坐标系。 绘图库可以基于数据的形状自动支持2D和3D渲染。 不是创建两个单独的模型，而是始终将z默认为 0 而不是undefined，这可能是有意义的。</p>
<h2 id="负索引数组">负索引数组</h2>
<p>在JS中获取数组中的最后一个元素方式通过写的很冗长且重复，也容易出错。 这就是为什么有一个TC39提案定义了一个便利属性Array.lastItem来获取和设置最后一个元素。<br>
其他语言，如Python和Ruby，使用负组索引更容易访问最后面的元素。例如，可以简单地使用arr[-1]替代arr[arr.length-1]访问最后一个元素。<br>
使用 Proxy 也可以在 Javascript 中使用负索引。</p>
<pre><code>const negativeArray = els =&gt;
    new Proxy(els, {
        get: (target, propKey, receiver) =&gt;
            Reflect.get(
                target,
                +propKey &lt; 0 ? String(target.length + +propKey) : propKey,
                receiver
            )
    });
</code></pre>
<p>一个重要的注意事项是包含handler.get的陷阱字符串化所有属性。 对于数组访问，我们需要将属性名称强制转换为Numbers，这样就可以使用一元加运算符简洁地完成。<br>
现在[-1]访问最后一个元素，[-2]访问倒数第二个元素，以此类推。</p>
<pre><code>const unicorn = negativeArray([&quot; &quot;, &quot; &quot;, &quot; &quot;]);
​
unicorn[-1]; // ' '
</code></pre>
<h2 id="隐藏属性">隐藏属性</h2>
<p>众所周知 JS 没有私有属性。 Symbol最初是为了启用私有属性而引入的，但后来使用像Object.getOwnPropertySymbols这样的反射方法进行了淡化，这使得它们可以被公开发现。<br>
长期以来的惯例是将私有属性命名为前下划线_，有效地标记它们“不要访问”。Prox 提供了一种稍微更好的方法来屏蔽这些属性。</p>
<pre><code>const hide = (target, prefix = &quot;_&quot;) =&gt;
    new Proxy(target, {
        has: (obj, prop) =&gt; !prop.startsWith(prefix) &amp;&amp; prop in obj,
        ownKeys: obj =&gt;
            Reflect.ownKeys(obj).filter(
                prop =&gt; typeof prop !== &quot;string&quot; || !prop.startsWith(prefix)
            ),
        get: (obj, prop, rec) =&gt; (prop in rec ? obj[prop] : undefined)
    });
</code></pre>
<p>hide函数包装目标对象，并使得从in运算符和Object.getOwnPropertyNames等方法无法访问带有下划线的属性。</p>
<pre><code>let userData = hide({
    firstName: &quot;Tom&quot;,
    mediumHandle: &quot;@tbarrasso&quot;,
    _favoriteRapper: &quot;Drake&quot;
});
​
userData._favoriteRapper(
    // undefined
    &quot;_favoriteRapper&quot; in userData
); // false
</code></pre>
<h2 id="缓存">缓存</h2>
<p>在客户端和服务器之间同步状态时遇到困难并不罕见。数据可能会随着时间的推移而发生变化，很难确切地知道何时重新同步的逻辑。<br>
Proxy启用了一种新方法：根据需要将对象包装为无效（和重新同步）属性。 所有访问属性的尝试都首先检查缓存策略，该策略决定返回当前在内存中的内容还是采取其他一些操作。</p>
<pre><code>const ephemeral = (target, ttl = 60) =&gt; {
    const CREATED_AT = Date.now();
    const isExpired = () =&gt; Date.now() - CREATED_AT &gt; ttl * 1000;
    return new Proxy(target, {
        get: (obj, prop) =&gt; (isExpired() ? undefined : Reflect.get(obj, prop))
    });
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react-router]]></title>
        <id>https://django-lee-tony.github.io/post/react-router/</id>
        <link href="https://django-lee-tony.github.io/post/react-router/">
        </link>
        <updated>2021-02-16T05:32:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="路由用来分发请求-后端是提供服务的所以它的路由是在找controller前端是显示页面的所以它的路由是在找component-本文将详细介绍react-router-dom的内容">路由用来分发请求。后端是提供服务的，所以它的路由是在找controller，前端是显示页面的，所以它的路由是在找component。本文将详细介绍react-router-dom的内容</h3>
<h2 id="router">Router</h2>
<p>Router是路由器组件的低阶接口，通常会使用如下某个高阶router来替代它</p>
<pre><code>&lt;BrowserRouter&gt;
&lt;HashRouter&gt;
&lt;MemoryRouter&gt;
&lt;NativeRouter&gt;
&lt;StaticRouter&gt;
</code></pre>
<h3 id="browserrouter">【BrowserRouter】</h3>
<p>最常用的是BrowserRouter</p>
<pre><code>import { BrowserRouter } from 'react-router-dom'

&lt;BrowserRouter
  basename={optionalString}
  forceRefresh={optionalBool}
  getUserConfirmation={optionalFunc}
  keyLength={optionalNumber}
&gt;
  &lt;App/&gt;
&lt;/BrowserRouter&gt;
</code></pre>
<p>1、basename: 当前位置的基准 URL。如果页面部署在服务器的二级（子）目录，需要将 basename 设置到此子目录。 正确的 URL 格式是前面有一个前导斜杠，但不能有尾部斜杠</p>
<pre><code>&lt;BrowserRouter basename=&quot;/calendar&quot;/&gt;
</code></pre>
<p>2、getUserConfirmation：当导航需要确认时执行的函数。默认使用 window.confirm</p>
<pre><code>// 使用默认的确认函数
const getConfirmation = (message, callback) =&gt; {
  const allowTransition = window.confirm(message)
  callback(allowTransition)
}

&lt;BrowserRouter getUserConfirmation={getConfirmation}/&gt;
</code></pre>
<p>3、forceRefresh：当设置为 true 时，在导航的过程中整个页面将会刷新。 只有当浏览器不支持 HTML5 的 history API 时，才设置为 true</p>
<pre><code>const supportsHistory = 'pushState' in window.history
&lt;BrowserRouter forceRefresh={!supportsHistory}/&gt;
</code></pre>
<p>4、keyLength：location.key 的长度。默认是 6</p>
<pre><code>&lt;BrowserRouter keyLength={12}/&gt;
</code></pre>
<p>5、BrowserRouter只能渲染单一子元素</p>
<h3 id="route">Route</h3>
<p>Route是react-router中最重要的组件，用来匹配请求并渲染相应组件<br>
1、path 路径的匹配值，可以包括以下几种特殊符号</p>
<pre><code>:paramName – 匹配一段位于 /、? 或 # 之后的 URL。 命中的部分将被作为一个参数
() – 在它内部的内容被认为是可选的
* – 匹配任意字符（非贪婪的）直到命中下一个字符或者整个 URL 的末尾，并创建一个 splat 参数
</code></pre>
<p>例子如下所示：</p>
<pre><code>&lt;Route path=&quot;/hello/:name&quot;&gt;         // 匹配 /hello/michael 和 /hello/ryan
&lt;Route path=&quot;/hello(/:name)&quot;&gt;       // 匹配 /hello, /hello/michael 和 /hello/ryan
&lt;Route path=&quot;/files/*.*&quot;&gt;           // 匹配 /files/hello.jpg 和 /files/path/to/hello.jpg
</code></pre>
<p>[注意]Route组件不能像普通组件一样，以属性的形式传递参数，但可以通过path属性来传递。但一定要区分router后面的:_id或:id</p>
<pre><code>'/category/:_id'
</code></pre>
<p>2、component 要显示的组件</p>
<pre><code>import { BrowserRouter as Router, Route } from 'react-router-dom'

&lt;Router&gt;
  &lt;div&gt;
    &lt;Route exact path=&quot;/&quot; component={Home}/&gt;
    &lt;Route path=&quot;/news&quot; component={NewsFeed}/&gt;
  &lt;/div&gt;
&lt;/Router&gt;
</code></pre>
<p>3、render 函数中return的值就是要显示的内容</p>
<pre><code>&lt;Route path=&quot;/home&quot; render={() =&gt; &lt;div&gt;Home&lt;/div&gt;}/&gt;
</code></pre>
<p>4、children与render的区别在于，不管有没有匹配，都想显示的内容</p>
<pre><code>const ListItemLink = ({ to, ...rest }) =&gt; (
  &lt;Route path={to} children={({ match }) =&gt; (
    &lt;li className={match ? 'active' : ''}&gt;
      &lt;Link to={to} {...rest}/&gt;
    &lt;/li&gt;
  )}/&gt;
)
</code></pre>
<p>[注意]component/render/children只能三个选一个使用</p>
<h3 id="匹配规则">【匹配规则】</h3>
<p>默认地，路由进行宽松匹配。在下面例子中，路由匹配到/one时，既显示组件A，也显示组件B</p>
<pre><code>&lt;Route  path=&quot;/one&quot; component={A}/&gt;
&lt;Route  path=&quot;/one/two&quot; component={B}/&gt;
</code></pre>
<p>如果要进行确切匹配，则需要添加exact属性。这样，路由匹配到/one时，只显示组件A</p>
<pre><code>&lt;Route  exact path=&quot;/one&quot; component={A}/&gt;
&lt;Route  path=&quot;/one/two&quot; component={B}/&gt;
</code></pre>
<p>还有一种是严格匹配，即斜杠也必须严格匹配。下面例子中，路由匹配到/one/时，会显示组件A，但匹配到/one时，什么都不会显示<br>
<code>&lt;Route strict path=&quot;/one/&quot; component={A}/&gt;</code><br>
　[注意]严格匹配并不是确切匹配。下面例子中，路由匹配到/one时，即显示组件A，也显示组件B</p>
<pre><code>&lt;Route  strict path=&quot;/one&quot; component={A}/&gt;
&lt;Route  path=&quot;/one/two&quot; component={B}/&gt;
</code></pre>
<p>如果要确切匹配，则需要<br>
<code>&lt;Route exact strict path=&quot;/one&quot; component={A}/&gt;</code><br>
　　但是，一般地，strict属性很少使用</p>
<h3 id="属性">【属性】</h3>
<p>Route默认携带三个props：包括match、location、history<br>
　　如果使用component，则使用this.props来获取，如果是render，则在回调函数中使用参数(props)=&gt;{}来获取<br>
　　1、match<br>
　　match包括以下属性</p>
<pre><code>params 键值对
isExact 是否确切匹配
path 路径中设置的值
url URL中的path值
</code></pre>
<p>2、location<br>
　　location中包含如下属性<br>
　　[注意]直接访问location，而不是访问history.location</p>
<pre><code>{
  key: 'ac3df4', // not with HashHistory!
  pathname: '/somewhere'
  search: '?some=search-string',
  hash: '#howdy',
  state: {
    [userDefined]: true
  }
}
</code></pre>
<p>通过Link传递的state，可以在location中获取到<br>
[注意]刚开始时，或者直接刷新浏览器，state是没有值的，只有跳转到该链接时，state才有值。再后来，刷新也有值了<br>
3、history<br>
　　history包含如下属性</p>
<pre><code>length: history栈的长度
action: 当前的action
location: 当前的location对象
</code></pre>
<p>history包含如下方法</p>
<pre><code>push()
goBack() = go(-1)
goForward() = go(1)
go() 跳转到 history栈中的哪个enter
replace(path, [state]) 替换history栈中的当前entry
push(path, [state])  添加当前entry到history栈中
</code></pre>
<h3 id="redirect">Redirect</h3>
<p>Redirect将页面导航到新位置，新位置将覆盖history栈中的当前位置，类似于服务器端的重定向(HTTP 3xx)<br>
to属性可以是一个字符串，表示跳转的地址</p>
<pre><code>&lt;Route exact path=&quot;/&quot; render={() =&gt; (
  loggedIn ? (
    &lt;Redirect to=&quot;/dashboard&quot;/&gt;
  ) : (
    &lt;PublicHomePage/&gt;
  )
)}/&gt;
</code></pre>
<p>to属性也可以是一个对象</p>
<pre><code>&lt;Redirect to={{
  pathname: '/login',
  search: '?utm=your+face',
  state: { referrer: currentLocation }
}}/&gt;
</code></pre>
<p>push属性为true时，表示添加新记录到history栈中，而不是替换当前记录<br>
<code>&lt;Redirect push to=&quot;/somewhere/else&quot;/&gt;</code><br>
　Link是对a标签的封装，提供无刷新的页面跳转。Link标签主要的属性是to属性<br>
　1、一般地，to是一个字符串<br>
<code>&lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt;</code><br>
2、也可以写成对象的形式</p>
<pre><code>&lt;Link to={{
  pathname: '/courses',
  search: '?sort=name',
  hash: '#the-hash',
  state: { fromDashboard: true }
}}/&gt;
</code></pre>
<p>[注意]在Link里的子组件或同组件的点击事件，最好加上阻止默认行为和阻止冒泡</p>
<pre><code>&lt;Link&gt;
  &lt;div onclick={}&gt;&lt;/div&gt;
&lt;/Link&gt;
&lt;Link onclick={}&gt;
</code></pre>
<h3 id="navlink">【NavLink】</h3>
<p>NavLink相对于Link来说，增加了一些样式属性<br>
　　activeClassName表示被匹配的a标签的样式名；activeStyle表示被匹配的a标签的样式</p>
<pre><code>&lt;NavLink
  to=&quot;/faq&quot;
  activeClassName=&quot;selected&quot;
&gt;FAQs&lt;/NavLink&gt;
</code></pre>
<pre><code>&lt;NavLink
  to=&quot;/faq&quot;
  activeStyle={{
    fontWeight: 'bold',
    color: 'red'
   }}
&gt;FAQs&lt;/NavLink&gt;
</code></pre>
<p>注意： link和history.push都不支持指向外网地址，如果要跳转到外网，则需要使用window对象下的location对象</p>
<h3 id="switch">Switch</h3>
<p>渲染Route或Redirect匹配到的第一个子元素</p>
<pre><code>&lt;Switch&gt;
  &lt;Route exact path=&quot;/&quot; component={Home}/&gt;
  &lt;Route path=&quot;/about&quot; component={About}/&gt;
  &lt;Route path=&quot;/:user&quot; component={User}/&gt;
  &lt;Route component={NoMatch}/&gt;
&lt;/Switch&gt;
</code></pre>
<p>[注意]switch必须直接包括Route，中间不可包含div，否则不生效</p>
<h3 id="跳转">跳转</h3>
<p>如果在实现逻辑跳转，可使用如下代码实现</p>
<pre><code>// utils/history.js
import createBrowserHistory from 'history/createBrowserHistory'
const customHistory = createBrowserHistory()
export default customHistory
</code></pre>
<p>引用如下</p>
<pre><code>import  history  from '@/utils/history'
// 跳转到首页
history.push('/')
</code></pre>
<p>要特别注意的是，如果使用utils/history.js，需要使用Router history={history}，而不是BrowserRouter<br>
　　因为全局只能有一个history实例。 使用import { BrowserRouter as Router } 语句，会自动创建一个history实例的，相当于有两个实例，则会出现URL发生变化，刷新页面后，页面才跳转的情况</p>
<pre><code>import { Router, Route, Switch, Redirect } from 'react-router-dom'
import history from '@/utils/history'

&lt;Router history={history}&gt;
  &lt;Switch&gt;
    &lt;Route path=&quot;/login&quot; component={Login} /&gt;
    &lt;Route path=&quot;/&quot; render={props =&gt; {if (sessionStorage.getItem('token') &amp;&amp; sessionStorage.getItem('user')) {return &lt;Home {...props} /&gt;
        }
        return &lt;Redirect to=&quot;/login&quot; /&gt;
      }} /&gt;
  &lt;/Switch&gt;
&lt;/Router&gt;
</code></pre>
<h3 id="传参">【传参】</h3>
<p>history.push方法也可以携带参数，方法如下</p>
<pre><code>history.push({
  pathname: '/about',
  search: '?the=search',
  state: { some: 'state' }
})
</code></pre>
<h3 id="基础案例">基础案例</h3>
<pre><code>import React from 'react'
import {
  BrowserRouter as Router,
  Route,
  Link
} from 'react-router-dom'

// 三个基础呈现组件

const Home = () =&gt; (
  &lt;div&gt;
    &lt;h2&gt;Home&lt;/h2&gt;
  &lt;/div&gt;
)

const About = () =&gt; (
  &lt;div&gt;
    &lt;h2&gt;About&lt;/h2&gt;
  &lt;/div&gt;
)

const Topic = ({ match }) =&gt; (
  &lt;div&gt;
    &lt;h3&gt;{match.params.topicId}&lt;/h3&gt;
  &lt;/div&gt;
)

// 一个内嵌的组件

const Topics = ({ match }) =&gt; (
  &lt;div&gt;
    &lt;h2&gt;Topics&lt;/h2&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;Link to={`${match.url}/rendering`}&gt;
          Rendering with React
        &lt;/Link&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;Link to={`${match.url}/components`}&gt;
          Components
        &lt;/Link&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;Link to={`${match.url}/props-v-state`}&gt;
          Props v. State
        &lt;/Link&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;Route path={`${match.url}/:topicId`} component={Topic}/&gt;
    &lt;Route exact path={match.url} render={() =&gt; (
      &lt;h3&gt;Please select a topic.&lt;/h3&gt;
    )}/&gt;
  &lt;/div&gt;
)

// 首页组件

const BasicExample = () =&gt; (
  &lt;Router&gt;
    &lt;div&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;&lt;/li&gt;
        &lt;li&gt;&lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;&lt;/li&gt;
        &lt;li&gt;&lt;Link to=&quot;/topics&quot;&gt;Topics&lt;/Link&gt;&lt;/li&gt;
      &lt;/ul&gt;

      &lt;hr/&gt;

      &lt;Route exact path=&quot;/&quot; component={Home}/&gt;
      &lt;Route path=&quot;/about&quot; component={About}/&gt;
      &lt;Route path=&quot;/topics&quot; component={Topics}/&gt;
    &lt;/div&gt;
  &lt;/Router&gt;
)
export default BasicExample
</code></pre>
<h3 id="exact">exact</h3>
<p>exact表示路由需要确切匹配，容易忽略的一点是，它与redux也有着非常密切的关系下面的代码是常见的增删改查的路由设置</p>
<pre><code>&lt;Switch&gt;
  &lt;Route path=&quot;/post/add&quot; component={AddPost} /&gt;  
  &lt;Route exact path=&quot;/post/:id&quot; component={ShowPost} /&gt;        
  &lt;Route path=&quot;/post/:id/update&quot; component={UpdatePost} /&gt;
  &lt;Route path=&quot;/post/:id/delete&quot; component={DeletePost} /&gt;
&lt;/Switch&gt;
</code></pre>
<p>代码中，通向showPost的路由设置了exact。一般地，showPost通过fetch获取了post，并保存到store中的state.post中<br>
　　如果此时点击到updatePost中，可以通过state.post来得到值。而如果在updatePost页面直接刷新的话，则state.post值为空<br>
　　如果要确保页面刷新后仍然能够取得值，则需要通过route中的location传值<br>
　　但是，这种方法有两个缺陷。一个是不访问showPost，而直接访问UpdatePost不会获得传递的值；另一个是直接在地址栏中更改URL也不会获取传递的值<br>
　　2、去掉exact和switch，同时需要更改样式和路由。使得path=&quot;/post/:id/update&quot;时，可以同时匹配ShowPost和UpdatePost，且UpdatePost的页面可以完全覆盖ShowPost的页面</p>
<pre><code>&lt;Route path=&quot;/posts/add&quot; component={AddPost} /&gt;  
&lt;Route path=&quot;/post/:id&quot; component={ShowPost} /&gt;        
&lt;Route path=&quot;/post/:id/update&quot; component={UpdatePost} /&gt;
&lt;Route path=&quot;/post/:id/delete&quot; component={DeletePost} /&gt;
</code></pre>
<p>但是，由于这种方法对样式的定制化需求较高，都需要设置为定位元素，且根据覆盖关系来确定z-index。并且页面尺寸都需要保持一致。可扩展性不强</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react学习之 react-redux]]></title>
        <id>https://django-lee-tony.github.io/post/react-xue-xi-zhi-react-redux/</id>
        <link href="https://django-lee-tony.github.io/post/react-xue-xi-zhi-react-redux/">
        </link>
        <updated>2021-02-06T05:35:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="核心概念">核心概念</h1>
<p>redux专注于状态管理，把所有的状态都存在一个对象中。核心概念包括：store、state、action、reducer</p>
<h3 id="store">【store】</h3>
<p>store是保存数据的地方，redux提供createStore函数来生成 Store。函数参数是后面要介绍的reducer</p>
<pre><code>import { createStore } from 'redux'
const store = createStore(reducer)
</code></pre>
<h3 id="state">【state】</h3>
<p>state是store的某个时刻的快照，可以通过store.getState()取得当前时刻的state</p>
<pre><code>const state = store.getState()
</code></pre>
<h3 id="action">【action】</h3>
<p>action用来改变state。action是一个对象，其中的type属性是必须的，其他的属性一般用来设置改变state需要的数据</p>
<pre><code>const action = {
  type: 'ADD_ONE',
  num: 1
}
</code></pre>
<p>store.dispatch()是发出action的唯一方法</p>
<pre><code>const action = {
  type: 'ADD_ONE',
  num: 1
}
store.dispatch(action)
</code></pre>
<h3 id="reducer">【reducer】</h3>
<p>reducer 是一个函数，它接受action和当前state作为参数，返回一个新的state</p>
<pre><code>import { createStore } from 'redux'
const store = createStore(reducer)

const reducer = (state = 10, action) =&gt; {
  switch (action.type) {
    case 'ADD_ONE':
      return state + action.num;
    default: 
      return state;
  }
};
当store.dispatch发送过来一个新的action，store就会自动调用reducer，得到新的state
</code></pre>
<h2 id="简单实例">简单实例</h2>
<pre><code>//第一步，创建action
const addOne = {
  type: 'ADD',
  num: 1
}
const addTwo = {
  type: 'ADD',
  num: 2
}
const square = {
  type: 'SQUARE'
}
//第二步，创建reducer
let math = (state = 10, action) =&gt; {
  switch (action.type) {
    case ADD:
      return state + action.num
    case SQUARE:
      return state * state
    default:
      return state
  }
}
//第三步，创建store
import { createStore } from 'redux'
const store = createStore(math)
//第四步，测试，通过dispatch发出action，并通过getState()取得当前state值
console.log(store.getState()) //默认值为10
store.dispatch(addOne) //发起'+1'的action
console.log(store.getState()) //当前值为10+1=11
store.dispatch(square) //发起'乘方'的action
console.log(store.getState()) //当前值为11*11=121
store.dispatch(addTwo) //发起'+2'的action
console.log(store.getState()) //当前值为121+2=123
</code></pre>
<h2 id="目录结构">目录结构</h2>
<h3 id="下面对目录结构进行划分">下面对目录结构进行划分</h3>
<p>1、一般地，将action.type设置为常量，这样在书写错误时，会得到报错提示</p>
<pre><code>// constants/ActionTypes.js
export const ADD = 'ADD'
export const SQUARE = 'SQUARE'
</code></pre>
<p>2、可以将addOne对象和addTwo对象整合成add函数的形式</p>
<pre><code>// action/math.js
import { ADD, SQUARE } from '../constants/ActionTypes'
export const add = num =&gt; ({ type: ADD, num })
export const square = { type: SQUARE }
</code></pre>
<p>3、根据action.type的分类来拆分reducer，最终通过combineReducers方法将拆分的reducer合并起来。上例中的action类型都是数字运算，无需拆分，只需进行如下变化</p>
<pre><code>// reducer/math.js
import { ADD, SQUARE } from '../constants/ActionTypes'
const math = (state = 10, action) =&gt; {
  switch (action.type) {
    case ADD:
      return state + action.num
    case SQUARE:
      return state * state
    default:
      return state
  }
}
export default math
</code></pre>
<pre><code>// reducer/index.js
import { combineReducers } from 'redux'
import math from './math'
const rootReducer = combineReducers({
  math
})
export default rootReducer
</code></pre>
<p>4、将store存储到store/index.js文件中</p>
<pre><code>// store/index.js
import { createStore } from 'redux'
import rootReducer from '../reducer'
export default createStore(rootReducer)
</code></pre>
<p>5、最终，根路径下的index.js内容如下所示</p>
<pre><code>import store from './store'
import {add, square} from './action/math'

console.log(store.getState()) //默认值为10

store.dispatch(add(1)) //发起'+1'的action
console.log(store.getState()) //当前值为10+1=11

store.dispatch(square) //发起'乘方'的action
console.log(store.getState()) //当前值为11*11=121

store.dispatch(add(2)) //发起'+2'的action
console.log(store.getState()) //当前值为121+2=123
</code></pre>
<h2 id="ui层">UI层</h2>
<p>前面的示例中，只是redux的状态改变，下面利用UI层来建立view和state的联系，将根目录下的index.js的内容更改如下<br>
import store from './store'<br>
import React from 'react'<br>
import ReactDOM from 'react-dom'<br>
import { add, square } from './action/math'</p>
<p>ReactDOM.render(</p>
  <div store={store}>
    <p>{store.getState().math}</p>
    <input type="button" onClick={() => store.dispatch(add(1))} value="+1" />
    <input type="button" onClick={() => store.dispatch(add(2))} value="+2" />
    <input type="button" onClick={() => store.dispatch(square)} value="乘方" />
  </div>,
  document.getElementById('root')
)
### 【store.subscribe()】
接下来介绍store.subscribe()方法了，该方法用来设置监听函数，一旦state发生变化，就自动执行这个函数。该方法的返回值是一个函数，调用这个函数可以解除监听
下面将示例代码更改如下
```
import store from './store'
import React from 'react'
import ReactDOM from 'react-dom'
import { add, square } from './action/math'
<p>const render = () =&gt; ReactDOM.render(</p>
  <div store={store}>
    <p>{store.getState().math}</p>
    <input type="button" onClick={() => store.dispatch(add(1))} value="+1" />
    <input type="button" onClick={() => store.dispatch(add(2))} value="+2" />
    <input type="button" onClick={() => store.dispatch(square)} value="乘方" />
  </div>,
  document.getElementById('root')
)
<p>render()<br>
store.subscribe(render)</p>
<pre><code>## 异步
redux默认只处理同步，对于API请求这样的异步任务则无能为力
接下来尝试使用axios的get方法来请求下面这个API
</code></pre>
<p>复制代码<br>
// constants/ActionTypes.js<br>
export const ADD = 'ADD'<br>
export const SQUARE = 'SQUARE'<br>
export const SET = 'SET'</p>
<p>// action/math.js<br>
import { ADD, SQUARE, SET } from '../constants/ActionTypes'<br>
export const add = num =&gt; ({ type: ADD, num })<br>
export const square = { type: SQUARE }<br>
export const setNum = num =&gt; ({type: SET,num})</p>
<p>// reduce/math.js<br>
import { ADD, SQUARE,SET } from '../constants/ActionTypes'<br>
const math = (state = 10, action) =&gt; {<br>
switch (action.type) {<br>
case ADD:<br>
return state + action.num<br>
case SQUARE:<br>
return state * state<br>
case SET:<br>
return action.num<br>
default:<br>
return state<br>
}<br>
}<br>
export default math</p>
<p>// index.js<br>
import store from './store'<br>
import React from 'react'<br>
import ReactDOM from 'react-dom'<br>
import { add, square, setNum } from './action/math'<br>
import axios from 'axios'<br>
let uri = 'https://jsonplaceholder.typicode.com/posts/2'<br>
const render = () =&gt; ReactDOM.render(</p>
  <div store={store}>
    <p>{store.getState().math}</p>
    <input type="button" onClick={() => {axios.get(uri).then(res => {store.dispatch(store.dispatch(setNum(res.data.id)))})}} value="设置Num" />
    <input type="button" onClick={() => store.dispatch(add(1))} value="+1" />
    <input type="button" onClick={() => store.dispatch(add(2))} value="+2" />
    <input type="button" onClick={() => store.dispatch(square)} value="乘方" />
  </div>,
  document.getElementById('root')
)
render()
store.subscribe(render)
```
但是，虽然API是异步操作，但store.dispatch并不是异步，而axios通过get方法请求回来数据后，store.dispatch在axios中的then方法中同步取得数据
### 【redux-thunk】
如果要使用真正的异步操作，即把axios方法封装到store.dispatch中，需要使用redux-thunk中间件
````
//下载
npm install --save redux-thunk
```
然后，使用applyMiddleware来使用thunk中间件
```
 import { createStore, applyMiddleware } from 'redux'
import thunk from 'redux-thunk'
import rootReducer from '../reducer'
export default createStore(rootReducer,applyMiddleware(thunk))
```
　接着来定义setNum这个action creator，然后在index.js文件的DOM加载完成后就发出setNum
* [注意]如果action是一个对象，则它就是一个action，如果action是一个函数，则它是一个action creator，即action制造器
<p>修改的代码如下</p>
<pre><code>// action/math.js
import { ADD, SQUARE, SET } from '../constants/ActionTypes'
import axios from 'axios'
const uri = 'https://jsonplaceholder.typicode.com/posts/2'
export const add = num =&gt; ({ type: ADD, num })
export const square = { type: SQUARE }
export const setNum = () =&gt; (dispatch, getState) =&gt; {
  return axios.get(uri).then(res =&gt; {
    dispatch({
      type: SET,
      num: res.data.id
    })
  })
}

// index.js
import store from './store'
import React from 'react'
import ReactDOM from 'react-dom'
import { add, square, setNum } from './action/math'
const render = () =&gt; ReactDOM.render(
  &lt;div store={store}&gt;
    &lt;p&gt;{store.getState().math}&lt;/p&gt;
    &lt;input type=&quot;button&quot; onClick={() =&gt; store.dispatch(setNum())} value=&quot;设置Num&quot; /&gt;
    &lt;input type=&quot;button&quot; onClick={() =&gt; store.dispatch(add(1))} value=&quot;+1&quot; /&gt;
    &lt;input type=&quot;button&quot; onClick={() =&gt; store.dispatch(add(2))} value=&quot;+2&quot; /&gt;
    &lt;input type=&quot;button&quot; onClick={() =&gt; store.dispatch(square)} value=&quot;乘方&quot; /&gt;
  &lt;/div&gt;,
  document.getElementById('root')
)
render()
store.subscribe(render)

</code></pre>
<h3 id="提示信息">【提示信息】</h3>
<p>如果做的更完备一点，应该把异步请求时的提示信息也加上。增加一个fetch的action，用于控制fetch过程的提示信息及显示隐藏情况<br>
代码更改如下</p>
<pre><code>import { SET_FETCH_MESSAGE, HIDE_FETCH_MESSAGE } from '../constants/ActionTypes'
export const startFetch = { type: SET_FETCH_MESSAGE,message: '开始发送异步请求' }
export const successFetch = { type: SET_FETCH_MESSAGE, message: '成功接收数据' }
export const failFetch = { type: SET_FETCH_MESSAGE, message: '接收数据失败' }
export const hideFetchMessage = { type: HIDE_FETCH_MESSAGE }
</code></pre>
<pre><code>// action/math.js
import { ADD, SQUARE, SET } from '../constants/ActionTypes'
import { startFetch, successFetch, failFetch, hideFetchMessage } from './fetch'
import axios from 'axios'
const uri = 'https://jsonplaceholder.typicode.com/posts/2'
export const add = num =&gt; ({ type: ADD, num })
export const square = { type: SQUARE }
export const setNum = () =&gt; (dispatch, getState) =&gt; {
  dispatch(startFetch)
  setTimeout(() =&gt; {
    dispatch(hideFetchMessage)
  }, 500)
  return axios
    .get(uri)
    .then(res =&gt; {
      setTimeout(() =&gt; {
        dispatch(successFetch)
        setTimeout(() =&gt; {
          dispatch(hideFetchMessage)
        }, 500)
        dispatch({ type: SET, num: res.data.id })
      }, 1000)
    })
    .catch(err =&gt; {
      dispatch(failFetch)
      setTimeout(() =&gt; {
        dispatch(hideFetchMessage)
      }, 500)
    })
}

</code></pre>
<pre><code>// constants/ActionTypes.js
export const ADD = 'ADD'
export const SQUARE = 'SQUARE'
export const SET = 'SET'
export const SET_FETCH_MESSAGE = 'SET_FETCH_MESSAGE'
export const HIDE_FETCH_MESSAGE = 'HIDE_FETCH_MESSAGE'
</code></pre>
<pre><code>// reduce/fetch.js
import { SET_FETCH_MESSAGE,HIDE_FETCH_MESSAGE } from '../constants/ActionTypes'
const initState = {
  message:'',
  isShow:false
}
const fetch = (state = initState, action) =&gt; {
  switch (action.type) {
    case SET_FETCH_MESSAGE:
      return {isShow: true, message: action.message}
    case HIDE_FETCH_MESSAGE:
      return { isShow: false, message: '' }
    default:
      return state
  }
}
export default fetch
</code></pre>
<pre><code>// index.js
import store from './store'
import React from 'react'
import ReactDOM from 'react-dom'
import { add, square, setNum } from './action/math'
const render = () =&gt; ReactDOM.render(
  &lt;div store={store}&gt;
    &lt;p&gt;{store.getState().math}&lt;/p&gt;
    &lt;input type=&quot;button&quot; onClick={() =&gt; store.dispatch(setNum())} value=&quot;设置Num&quot; /&gt;
    &lt;input type=&quot;button&quot; onClick={() =&gt; store.dispatch(add(1))} value=&quot;+1&quot; /&gt;
    &lt;input type=&quot;button&quot; onClick={() =&gt; store.dispatch(add(2))} value=&quot;+2&quot; /&gt;
    &lt;input type=&quot;button&quot; onClick={() =&gt; store.dispatch(square)} value=&quot;乘方&quot; /&gt;
    {store.getState().fetch.isShow &amp;&amp; &lt;p&gt;{store.getState().fetch.message}&lt;/p&gt;}
  &lt;/div&gt;,
  document.getElementById('root')
)
render()
store.subscribe(render)
</code></pre>
<h2 id="展示和容器">展示和容器</h2>
<p>下面来介绍react-redux。前面的代码中，我们是通过store.subscribe()方法监控state状态的变化来更新UI层的。而使用react-redux，可以让组件动态订阅状态树。状态树一旦被修改，组件能自动刷新显示最新数据<br>
　react-redux将所有组件分成两大类：展示组件和容器组件。展示组件只负责UI呈现，所有数据由参数props提供；容器组件则负责管理数据和业务逻辑，带有内部状态，可使用redux的API。要使用react-redux，就要遵守它的组件拆分规范</p>
<h3 id="provider">【provider】</h3>
<p>react-redux提供Provider组件，可以让容器组件默认可以拿到state，而不用当容器组件层级很深时，一级级将state传下去<br>
将index.js文件更改如下</p>
<pre><code>// index.js
import React from 'react'
import ReactDOM from 'react-dom'
import store from './store'
import MathContainer from './container/MathContainer'
import { Provider } from 'react-redux'
ReactDOM.render(
  &lt;Provider store={store}&gt;
    &lt;MathContainer /&gt;
  &lt;/Provider&gt;,
  document.getElementById('root')
)
</code></pre>
<p>按照组件拆分规范，将原来index.js中相关代码，分拆到container/MathContainer和component/Math这两个组件中</p>
<h3 id="connect">【connect】</h3>
<p>react-redux提供connect方法，用于从展示组件生成容器组件。connect的意思就是将这两种组件连接起来</p>
<pre><code>import { connect } from 'react-redux'
const MathContainer = connect()(Math);
</code></pre>
<p>Math是展示组件，MathContainer就是由React-redux通过connect方法自动生成的容器组件<br>
　　为了定义业务逻辑，需要给出下面两方面的信息<br>
　　1、输入逻辑：外部的数据(即state对象)如何转换为展示组件的参数<br>
　　2、输出逻辑：用户发出的动作如何变为Action对象，从展示组件传出去<br>
　　因此，connect方法的完整API如下</p>
<pre><code>import {connect} from 'react-redux'
const MathContainer= connect(
    mapStateToProps,
    mapDispatchToProps
)(Math)
</code></pre>
<p>上面代码中，connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了展示组件的业务逻辑。前者负责输入逻辑，即将state映射到UI组件的参数(props)，后者负责输出逻辑，即将用户对展示组件的操作映射成Action</p>
<h3 id="mapstatetoprops">【mapStateToProps()】</h3>
<p>mapStateToProps建立一个从外部的state对象到展示组件的props对象的映射关系。作为参数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射</p>
<pre><code>const mapStateToProps = (state) =&gt; {
  return {
    num: getNum(state)                  
  }  
}
</code></pre>
<p>mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象。使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发展示组件重新渲染</p>
<pre><code>const mapStateToProps = (state,ownProps) =&gt; {
  return {
    num: getNum(state)                  
  }  
}
</code></pre>
<p>mapStateToProps会订阅Store，每当state更新的时候，就会自动执行，重新计算展示组件的参数，从而触发展示组件的重新渲染。connect方法可以省略mapStateToProps参数，那样，展示组件就不会订阅Store，就是说Store的更新不会引起展示组件的更新</p>
<h3 id="mapdispatchtoprops">【mapDispatchToProps】</h3>
<p>mapDispatchToProps是connect函数的第二个参数，用来建立展示组件的参数到store.dispatch方法的映射。也就是说，它定义了用户的哪些操作应该当作action，传给Store。它可以是一个函数，也可以是一个对象<br>
　　如果mapDispatchToProps是一个函数，会得到dispatch和ownProps(容器组件的props对象)两个参数</p>
<pre><code>const mapDispatchToProps = (dispatch,ownProps) =&gt; {
  return {
    onSetNumClick: () =&gt; dispatch(setNum())
  }
}
</code></pre>
<p>mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了展示组件的参数怎样发出action<br>
　　如果mapDispatchToProps是一个对象，它的每个键名也是对应展示组件的同名参数，键值应该是一个函数，会被当作action creator，返回的action会由redux自动发出<br>
　　因此，上面的写法简写如下所示</p>
<pre><code>const mapDispatchToProps = {
  onsetNumClick: () =&gt; setNum()
}
</code></pre>
<h3 id="components">【components】</h3>
<pre><code>// components/Math.js
import React from 'react'
const Math = ({
  num,
  isShow,
  fetchMessage,
  onSetNumClick,
  onAddOneClick,
  onAddTwoClick,
  onSqureClick
}) =&gt; (
  &lt;section&gt;
    &lt;p&gt;{num}&lt;/p&gt;
    &lt;input type=&quot;button&quot; onClick={onSetNumClick} value=&quot;设置Num&quot; /&gt;
    &lt;input type=&quot;button&quot; onClick={onAddOneClick} value=&quot;+1&quot; /&gt;
    &lt;input type=&quot;button&quot; onClick={onAddTwoClick} value=&quot;+2&quot; /&gt;
    &lt;input type=&quot;button&quot; onClick={onSqureClick} value=&quot;乘方&quot; /&gt;
    {isShow &amp;&amp; &lt;p&gt;{fetchMessage}&lt;/p&gt;}
  &lt;/section&gt;
)

export default Math

</code></pre>
<h3 id="containers">【containers】</h3>
<pre><code>        // containers/MathContainer.js
        import { connect } from 'react-redux'
        import Math from '../components/Math'
        import { getNum } from '../selectors/math'
        import { getFetchMessage, getFetchIsShow } from '../selectors/fetch'
        import { setNum, add, square } from '../actions/math'
        const mapStateToProps = state =&gt; {
        return {
            num: getNum(state),
            fetchMessage: getFetchMessage(state),
            isShow: getFetchIsShow(state)
        }
        }
        const mapDispatchToProps = {
        onSetNumClick: () =&gt; setNum(),
        onAddOneClick: () =&gt; add(1),
        onAddTwoClick: () =&gt; add(2),
        onSqureClick: () =&gt; square
        }
        const MathContainer = connect(mapStateToProps, mapDispatchToProps)(Math)
        export default MathContainer
</code></pre>
<h3 id="actions">【actions】</h3>
<pre><code>// actions/fetch.js
import { SET_FETCH_MESSAGE, HIDE_FETCH_MESSAGE } from '../constants/ActionTypes'
export const startFetch = { type: SET_FETCH_MESSAGE,message: '开始发送异步请求' }
export const successFetch = { type: SET_FETCH_MESSAGE, message: '成功接收数据' }
export const failFetch = { type: SET_FETCH_MESSAGE, message: '接收数据失败' }
export const hideFetchMessage = { type: HIDE_FETCH_MESSAGE }
</code></pre>
<pre><code>// actions/math.js
import { ADD, SQUARE, SET } from '../constants/ActionTypes'
import { startFetch, successFetch, failFetch, hideFetchMessage } from './fetch'
import axios from 'axios'
const uri = 'https://jsonplaceholder.typicode.com/posts/2'
export const add = num =&gt; ({ type: ADD, num })
export const square = { type: SQUARE }
export const setNum = () =&gt; (dispatch, getState) =&gt; {
  dispatch(startFetch)
  setTimeout(() =&gt; {dispatch(hideFetchMessage)}, 300)
  return axios
    .get(uri)
    .then(res =&gt; {
      dispatch(successFetch)
      setTimeout(() =&gt; {dispatch(hideFetchMessage)}, 300)
      dispatch({ type: SET, num: res.data.id })
    })
    .catch(err =&gt; {
      dispatch(failFetch)
      setTimeout(() =&gt; {dispatch(hideFetchMessage)}, 300)
    })
}
</code></pre>
<h3 id="constants">【constants】</h3>
<pre><code>// constants/ActionTypes.js
export const ADD = 'ADD'
export const SQUARE = 'SQUARE'
export const SET = 'SET'
export const SET_FETCH_MESSAGE = 'SET_FETCH_MESSAGE'
export const HIDE_FETCH_MESSAGE = 'HIDE_FETCH_MESSAGE'
</code></pre>
<h3 id="reducers">【reducers】</h3>
<pre><code>// reducers/fetch.js
import { SET_FETCH_MESSAGE,HIDE_FETCH_MESSAGE } from '../constants/ActionTypes'
const initState = {
  message:'',
  isShow:false
}
const fetch = (state = initState, action) =&gt; {
  switch (action.type) {
    case SET_FETCH_MESSAGE:
      return {isShow: true, message: action.message}
    case HIDE_FETCH_MESSAGE:
      return { isShow: false, message: '' }
    default:
      return state
  }
}
export default fetch
</code></pre>
<pre><code>// reducers/index.js
import { combineReducers } from 'redux'
import math from './math'
import fetch from './fetch'
const rootReducer = combineReducers({
  math,
  fetch
})

export default rootReducer
</code></pre>
<pre><code>import { ADD, SQUARE,SET } from '../constants/ActionTypes'
const math = (state = 10, action) =&gt; {
  switch (action.type) {
    case ADD:
      return state + action.num
    case SQUARE:
      return state * state
    case SET:
      return action.num
    default:
      return state
  }
}
export default math
</code></pre>
<h3 id="selectors">【selectors】</h3>
<pre><code>// selectors/fetch.js
export const getFetchMessage = state =&gt; state.fetch.message
export const getFetchIsShow = state =&gt; state.fetch.isShow
</code></pre>
<pre><code>// selectors/math.js
export const getNum = state =&gt; state.math
</code></pre>
<h3 id="根目录">【根目录】</h3>
<pre><code>// index.js
import React from 'react'
import ReactDOM from 'react-dom'
import store from './store'
import MathContainer from './containers/MathContainer'
import { Provider } from 'react-redux'
ReactDOM.render(
  &lt;Provider store={store}&gt;
    &lt;MathContainer /&gt;
  &lt;/Provider&gt;,
  document.getElementById('root')
)
</code></pre>
<pre><code>// store.js
import { createStore, applyMiddleware } from 'redux'
import thunk from 'redux-thunk'
import rootReducer from './reducers'
export default createStore(rootReducer,applyMiddleware(thunk))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[封装简易swiper]]></title>
        <id>https://django-lee-tony.github.io/post/feng-zhuang-jian-yi-swiper/</id>
        <link href="https://django-lee-tony.github.io/post/feng-zhuang-jian-yi-swiper/">
        </link>
        <updated>2021-02-05T13:04:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="因为项目中一些特殊的需求-需要一些特殊的swiper-在三方插件求而不得的情况下-不得已选择自己封装-基于css3属性-transition过度属性以及vue-transition组件封装">因为项目中一些特殊的需求 需要一些特殊的swiper 在三方插件求而不得的情况下 不得已选择自己封装  基于css3属性 transition过度属性以及vue transition组件封装</h2>
<h3 id="页面部分">页面部分</h3>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;div class=&quot;bwg-swiper&quot; @mouseenter=&quot;enterTarget&quot; @mouseleave=&quot;leaveTarget&quot;&gt;
            &lt;div class=&quot;swiper-slide&quot; v-for=&quot;(item,i) in list&quot; :key=&quot;i&quot;&gt;
                &lt;transition name=&quot;scaleToBig&quot;&gt;
                    &lt;div class=&quot;swiper-list&quot; v-if=&quot;index==i&quot;&gt;
                        &lt;img width=&quot;100%&quot; height=&quot;100%&quot; :src=&quot;item&quot; alt=&quot;&quot;&gt;
                    &lt;/div&gt;
                &lt;/transition&gt;
            &lt;/div&gt;
            &lt;div class=&quot;indicator-par &quot;&gt;
                &lt;div class=&quot;bwg-indicator indicator&quot; :class=&quot;{'bwg-indicator__active':index==i}&quot; @click=&quot;changIndex(i)&quot; v-for=&quot;(item,i) in list&quot; :key=&quot;i&quot;&gt;
&lt;!--                    显示的图片--&gt;
                    &lt;div class=&quot;show-img&quot;&gt;&lt;img :src=&quot;item&quot; alt=&quot;&quot;&gt;&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;transition enter-active-class=&quot;animated slideInLeft&quot; leave-active-class=&quot;animated slideOutLeft&quot;&gt;
                &lt;div class=&quot;bwg-prev bwg-swiper-push&quot; v-show=&quot;userEnter&quot; @click=&quot;editIndex('prev')&quot;&gt;〈&lt;/div&gt;
            &lt;/transition&gt;
            &lt;transition enter-active-class=&quot;animated slideInRight&quot; leave-active-class=&quot;animated slideOutRight&quot;&gt;
                &lt;div class=&quot;bwg-next bwg-swiper-push&quot; v-show=&quot;userEnter&quot; @click=&quot;editIndex('next')&quot;&gt;〉&lt;/div&gt;
            &lt;/transition&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h3 id="js部分">js部分</h3>
<pre><code>&lt;script&gt;

    export default {
        name:&quot;swiperCom&quot;,
        props:{
            autoplay:{
                type:Boolean,
                default:true
            },
            loop:{
                type:Boolean,
                default:true
            },
            delay:{
                type:Number,
                default:3000
            }
        },
        data() {
            return {
                timer:null,
                list:[
                ],
                index:0,
                userEnter:false
            };
        },
        mounted() {
          this.startMove()
        },
        methods:{
            //轮播开始计时
            startMove(){
                if(this.autoplay) { //是否自动轮播
                    if(this.timer) clearInterval(this.timer);
                    this.timer=setInterval(()=&gt;{
                        this.index++
                        if(this.index&gt;this.list.length-1){
                            this.index=0
                        }

                    },this.delay)
                }
            },
            //关闭计时器
            closeTimer(){
              if(this.timer){
                  clearInterval(this.timer)
              }
            },
            //鼠标划入
            enterTarget(){
                // console.log(1111);
                this.userEnter=true
               this.closeTimer()
            },
            //鼠标移出
            leaveTarget(){

                this.userEnter=false;
                this.startMove()
            },
            changIndex(i){
                this.index=i
            },
            editIndex(type){
                if(type=='prev'){
                   if(this.index&lt;=0){
                       this.index=this.list.length-1
                   }else{
                       this.index--
                   }
                }else{
                    if(this.index&gt;=this.list.length-1){
                        this.index=0
                    }else{
                        this.index++
                    }
                }
            }
        }
    }
&lt;/script&gt;
</code></pre>
<h3 id="style部分">style部分</h3>
<pre><code>&lt;style lang=&quot;scss&quot; scoped&gt;
    .bwg-swiper{
        height: 600px;
        width: 100%;
        min-width: $base-min-width;
        position: relative;
        z-index: 10;
        overflow: hidden;

        .swiper-slide{

            width: 1920px;
            margin: 0 auto;
            height: 100%;
            /*width: 100%;*/
            /*height: 100%;*/
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: 0;
            .swiper-list{
                width: 100%;
                height: 100%;
                position: absolute;
                left: 0;
                top: 0;
            }
        }
        .indicator-par{
            position: absolute;
            width: 100%;
            left: 0;
            bottom: 30px;
            z-index: 12;
            display: flex;
            justify-content: center;
            .indicator{
                position: relative;
                &amp;:hover{
                  .show-img{
                      display: block;
                  }
                }
               .show-img{
                   position: absolute;
                   width: 200px;
                   height: 50px;
                   border-radius: 5px;
                   box-shadow: 0px 0px 15px #00000029;
                   left: -90px;
                   top: -70px;
                   display: none;
                   overflow: hidden;
                   img{
                       width: 100%;
                       height: 100%;
                   }
               }
            }
        }
        .bwg-swiper-push{
            width: 40px;
            height: 80px;
            position: absolute;
            top: 220px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            color: #fff;
            background-color: #666;
            z-index: 13;
            cursor: pointer;
        }
        .bwg-prev{
            left: 0;
        }
        .bwg-next{
            right: 0;
        }
    }
&lt;/style&gt;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue webpack常规配置]]></title>
        <id>https://django-lee-tony.github.io/post/vue-webpack-chang-gui-pei-zhi/</id>
        <link href="https://django-lee-tony.github.io/post/vue-webpack-chang-gui-pei-zhi/">
        </link>
        <updated>2021-02-05T12:11:55.000Z</updated>
        <content type="html"><![CDATA[<h3 id="vueconfigjs">vue.config.js</h3>
<pre><code>const path = require('path')

function resolve(dir) {
    return path.join(__dirname, '.', dir)
}
module.exports={
    lintOnSave:false,
    productionSourceMap: process.env.NODE_ENV === 'development',
    devServer: {
        overlay: {
            warning: false,
            errors: false
        },
        open: true,
        proxy:{
            &quot;/api&quot;:{
                target: &quot;http://sp8001.sp.com:8888/&quot;,
            }
        }
    },
    css:{
        sourceMap:  process.env.NODE_ENV === 'development',// 开启 CSS source maps
        loaderOptions: {
            sass: {
                prependData: &quot;@import '~@/assets/style/public.scss';&quot;
            },
        }
    },
},
//合并配置
chainWebpack(config){
    config.plugins
            .delete('prefetch')
            .delete('preload')
        // 解决 cli3 热更新失效 https://github.com/vuejs/vue-cli/issues/1559
        config.resolve
            .symlinks(true)
    config.entry('main').add('babel-polyfill')
    // 开启图片压缩
        config.module.rule('images')
            .test(/\.(png|jpe?g|gif)(\?.*)?$/)
            .use('image-webpack-loader')
            .loader('image-webpack-loader')
            .options({ bypassOnDebug: true })
        if (process.env.NODE_ENV === 'production') {
            return {
                plugins: [
                    new CompressionPlugin({
                        test: /\.js$|\.ttf$|\.html$|\.css$|\.jpg$|\.jpeg$|\.png/, // 需要压缩的文件类型
                        threshold: 1024, // 归档需要进行压缩的文件大小最小值，我这个是10K以上的进行压缩
                        deleteOriginalAssets: false, // 是否删除原文件
                        minRatio: 0.8
                    })
                ]
            }
        }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react学习 生命周期]]></title>
        <id>https://django-lee-tony.github.io/post/react-xue-xi-sheng-ming-zhou-qi/</id>
        <link href="https://django-lee-tony.github.io/post/react-xue-xi-sheng-ming-zhou-qi/">
        </link>
        <updated>2021-02-05T09:46:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="react">React</h1>
<h2 id="组件生命周期">组件生命周期</h2>
<p>每一个组件都有几个可以重写以让代码在处理环节的特定时期运行的“生命周期方法”。方法中带有前缀 will 的在特定环节之前被调用，而带有前缀 did 的方法则会在特定环节之后被调用</p>
<h3 id="装配">【装配】</h3>
<p>这些方法会在组件实例被创建和插入DOM中时被调用：</p>
<pre><code class="language-$xslt">constructor()
static getDerivedStateFromProps()
componentWillMount()（版本17之后失效）
render()
componentDidMount()
</code></pre>
<h3 id="更新">【更新】</h3>
<p>属性或状态的改变会触发一次更新。当一个组件在被重渲时，这些方法将会被调用：</p>
<pre><code class="language-$xslt">componentWillReceiveProps()（版本17之后失效）
static getDerivedStateFromProps()
shouldComponentUpdate()
componentWillUpdate() （版本17之后失效）
render()
getSnapshotBeforeUpdate()
componentDidUpdate()
</code></pre>
<h3 id="卸载">【卸载】</h3>
<p>当一个组件被从DOM中移除时，该方法被调用：<br>
componentWillUnmount()</p>
<h3 id="错误处理">【错误处理】</h3>
<p>在渲染过程中发生错误时会被调用<br>
<code>componentDidCatch()</code></p>
<h2 id="装配过程">装配过程</h2>
<h3 id="render">【render()】</h3>
<p>render()函数应该纯净，意味着其不应该改变组件的状态，其每次调用都应返回相同的结果，同时不直接和浏览器交互。若需要和浏览器交互，将任务放在componentDidMount()阶段或其他的生命周期方法<br>
render 函数应该是一个纯函数，完全根据this.state和this.props来决定返回的结果，而且不要产生任何副作用。在render函数中调用this.setState毫无疑问是错误的，因为一个纯函数不应该引起状态的改变</p>
<h3 id="constructorprops">【constructor(props)】</h3>
<p>React组件的构造函数将会在装配之前被调用。当为一个React.Component子类定义构造函数时，应该在任何其他的表达式之前调用super(props)。否则，this.props在构造函数中将是未定义，并可能引发异常</p>
<h3 id="static-getderivedstatefrompropsnextprops-prevstate">【static getDerivedStateFromProps(nextProps, prevState)】</h3>
<pre><code>组件实例化后和接受新属性时将会调用getDerivedStateFromProps。它应该返回一个对象来更新状态，或者返回null来表明新属性不需要更新任何状态
</code></pre>
<p>[注意1]如果父组件导致了组件的重新渲染，即使属性没有更新，这一方法也会被调用<br>
　　[注意2]调用this.setState() 通常不会触发 getDerivedStateFromProps()<br>
典型用法如下所示：<br>
<code>static getDerivedStateFromProps() { return { indexOfShowControl: -1 } }</code></p>
<h3 id="componentdidmount">【componentDidMount()】</h3>
<pre><code>componentDidMount()在组件被装配后立即调用。初始化使得DOM节点应该进行到这里。若需要从远端加载数据，这是一个适合实现网络请求的地方
在这个方法中调用setState()将会触发一次额外的渲染，但是它将在浏览器刷新屏幕之前发生。这保证了即使render()将会调用两次，但用户不会看到中间状态。谨慎使用这一模式，因为它常导致性能问题
</code></pre>
<h2 id="更新及卸载">更新及卸载</h2>
<h3 id="shouldcomponentupdatenextprops-nextstate">【shouldComponentUpdate(nextProps, nextState)】</h3>
<pre><code>　使用shouldComponentUpdate()可以让React知道当前状态或属性的改变是否不影响组件的输出。默认行为是在每一次状态的改变重渲，在大部分情况下应该依赖于默认行为
当接收到新属性或状态时，shouldComponentUpdate() 在渲染前被调用。默认为true
若该方法返回false，则componentWillUpdate()、componentDidUpdate()、render()将不会被调用
*** [注意]该方法并不会在初始化渲染或当使用forceUpdate()时被调用
</code></pre>
<h3 id="getsnapshotbeforeupdate">【getSnapshotBeforeUpdate()】</h3>
<pre><code>getSnapshotBeforeUpdate()在最新的渲染输出提交给DOM前将会立即调用。它让组件能去获得当前的值在它们可能要改变前。这一生命周期返回的任何值将会作为参数被传递给componentDidUpdate()
[注意]该方法必须与componentDidUpdate()方法一起使用
</code></pre>
<h3 id="componentdidupateprevprops-prevstate">【componentDidUpate(prevProps, prevState)】</h3>
<pre><code>componentDidUpdate()会在更新发生后立即被调用。该方法并不会在初始化渲染时调用。当组件被更新时，使用该方法是操作DOM的一次机会。这也是一个适合发送请求的地方
</code></pre>
<h3 id="componentwillunmount">【componentWillUnmount()】</h3>
<pre><code>componentWillUnmount()在组件被卸载和销毁之前立刻调用。可以在该方法里处理任何必要的清理工作，例如解绑定时器，取消网络请求，清理任何在componentDidMount环节创建的DOM元素
</code></pre>
<h2 id="强制渲染">强制渲染</h2>
<h3 id="componentforceupdatecallback">【component.forceUpdate(callback)】</h3>
<pre><code>　默认情况，当组件或状态发生改变，组件将会重渲。若render()方法依赖其他数据，可以通过调用forceUpdate()来告诉React组件需要重渲
调用forceUpdate()将会导致组件的 render()方法被调用，并忽略shouldComponentUpdate()。这将会触发每一个子组件的生命周期方法，涵盖每个子组件的shouldComponentUpdate() 方法。若当标签改变，React仅会更新DOM
通常应该尝试避免所有forceUpdate() 的用法并仅在render()函数里从this.props和this.state读取数据
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[create-project-of-vue2]]></title>
        <id>https://django-lee-tony.github.io/post/create-project-of-vue2/</id>
        <link href="https://django-lee-tony.github.io/post/create-project-of-vue2/">
        </link>
        <updated>2021-02-05T09:46:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="安装">安装</h1>
<h2 id="卸载旧版本">卸载旧版本：</h2>
<h3 id="如果你之前都是基于vue-cli2x你需要先卸载它">如果你之前都是基于vue-cli2.X,你需要先卸载它：</h3>
<pre><code>#卸载vue-cli 老版本的cli
npm uninstall -g vue-cli
</code></pre>
<h2 id="安装-2">安装</h2>
<pre><code>npm install -g @vue/cli  // 安装cli3.x
vue --version 或者 vue -V  //查看版本是否为3.x
</code></pre>
<h1 id="创建项目">创建项目</h1>
<pre><code class="language-$xslt">vue create my-project // 其中my-project为项目目录名称
</code></pre>
<h3 id="此处有两个选择">此处有两个选择：</h3>
<pre><code class="language-$xslt">default (babel, eslint) 默认配置 提供babel和eslint支持
Manually select features 自己手动去选择需要的配置
</code></pre>
<h3 id="选择手动后">选择手动后</h3>
<pre><code class="language-$xslt">对于每一项的功能，做一下简单阐述：
Babel 主要是对es6语法转换成兼容的js （选上）
TypeScript 支持使用TypeScript语法来编写代码
PWA PWA 支持
Router 支持vue路由配置插件（一般都会选择）
Vuex 支持vue程序状态管理模式 (一般都会选择)
CSS Pre-processors 支持css预处理器 （一般都会选择）
Linter / Formatter 支持代码风格检查和格式化 （选上）
Unit Testing 单元测试
E2E Testing E2E测试
</code></pre>
<h3 id="当我们需要自定义webpack相关配置的时候需要在项目根目录中创建vueconfigjs文件它会被vuecli-server自动加载相关配置内容官网将的很详细">当我们需要自定义webpack相关配置的时候需要在项目根目录中创建vue.config.js文件，它会被@vue/cli-server自动加载，相关配置内容官网将的很详细</h3>
<pre><code class="language-$xslt">当我们需要调整webpac k配置的时候，
可以通过chainWebpack属性进行链式操作，
这里有个技巧就是通过 vue inspect --mode production product.js 
或vue inspect &gt; development.js 
来导处生产和开发环境的配置文件，文件里面包含了链式访问的规则，
这样我们就可以通过链式操作来修改添加webpack配置。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[svg正确使用方式]]></title>
        <id>https://django-lee-tony.github.io/post/svg-zheng-que-shi-yong-fang-shi/</id>
        <link href="https://django-lee-tony.github.io/post/svg-zheng-que-shi-yong-fang-shi/">
        </link>
        <updated>2021-02-05T09:45:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="svg正确使用方式">svg正确使用方式</h1>
<h2 id="svg-sprite-loader-下载">svg-sprite-loader 下载</h2>
<pre><code class="language-$xslt">npm i svg-sprite-loader 或者 yarn add svg-sprite-loader
</code></pre>
<h2 id="新建vueconfigjs-创建srcassetssvg-文件夹-将svg放入该文件夹中">新建vue.config.js 创建src/assets/svg 文件夹  将svg放入该文件夹中</h2>
<pre><code class="language-$xslt">const path = require(&quot;path&quot;);
function resolve(dir) {
    return path.join(__dirname, &quot;.&quot;, dir);
}
module.exports={
    ...
    chainwebpack:config =&gt;{
        ...
    config.module.rules.delete(&quot;svg&quot;); //重点:删除默认配置中处理svg,
            //const svgRule = config.module.rule('svg')
            //svgRule.uses.clear()
            config.module
                .rule(&quot;svg-sprite-loader&quot;)
                .test(/\.svg$/)
                .include.add(resolve(&quot;src/assets/svg&quot;)) //处理svg目录
                .end()
                .use(&quot;svg-sprite-loader&quot;)
                .loader(&quot;svg-sprite-loader&quot;)
                .options({
                    symbolId: &quot;icon-[name]&quot;
                });
    }
}
</code></pre>
<h2 id="封装组件">封装组件</h2>
<h3 id="新建indexvue">新建index.vue</h3>
<pre><code class="language-$xslt">//index.vue
&lt;template&gt;
    &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot;&gt;
        &lt;use :xlink:href=&quot;iconName&quot;/&gt;
    &lt;/svg&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        name: 'SvgIcon',
        props: {
            iconClass: { //接收svg名称 注意就是svg文件名
                type: String,
                required: true
            },
            className: { //svg图标的属性 如通过font-sizee属性控制icon大小
                type: String,
                default: ''
            }
        },
        computed: {
            iconName() {
                return `#icon-${this.iconClass}`
            },
            svgClass() {
                if (this.className) {
                    return 'svg-icon ' + this.className
                } else {
                    return 'svg-icon'
                }
            }
        }
    }
&lt;/script&gt;
&lt;style scoped&gt;
    .svg-icon {
        width: 1em;
        height: 1em;
        vertical-align: -0.15em;
        fill: currentColor;
        overflow: hidden;
    }
&lt;/style&gt;

</code></pre>
<h3 id="indexjs文件">index.js文件</h3>
<pre><code class="language-$xslt">//使用webpack提供的 require.context方法 引入所有的svg
import svgIcon from &quot;./index.vue&quot;
const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)
const req = require.context('../../assets/svg', false, /\.svg$/)
requireAll(req)
// 暴露方法
export default {
    install(Vue){
        Vue.component('svgIcon',svgIcon);
    }
}
</code></pre>
<h2 id="使用方式">使用方式</h2>
<pre><code class="language-$xslt"> &lt;svg-icon  icon-class=&quot;svgname&quot; class-name=&quot;svgclass&quot;&gt;&lt;/svg-icon&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue封装message组件]]></title>
        <id>https://django-lee-tony.github.io/post/vue-feng-zhuang-message-zu-jian/</id>
        <link href="https://django-lee-tony.github.io/post/vue-feng-zhuang-message-zu-jian/">
        </link>
        <updated>2021-02-05T09:45:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基于-element-源码改造-再封装">基于 element 源码改造 再封装</h1>
<h2 id="先封装-vue部分">先封装 .vue部分</h2>
<pre><code class="language-$xslt">&lt;template&gt;
  &lt;transition name=&quot;el-message-fade&quot; @after-leave=&quot;handleAfterLeave&quot;&gt;
    &lt;div
      :class=&quot;[
        'bwg-message',
        type &amp;&amp; !iconClass ? `white-${type}` : '',
        center ? 'is-center' : '',
        showClose ? 'is-closable' : '',
        customClass
      ]&quot;
      :style=&quot;positionStyle&quot;
      v-show=&quot;visible&quot;
      @mouseenter=&quot;clearTimer&quot;
      @mouseleave=&quot;startTimer&quot;
      role=&quot;alert&quot;
    &gt;
      &lt;div&gt;
&lt;!--        &lt;i :class=&quot;iconClass&quot; v-if=&quot;iconClass&quot;&gt;&lt;/i&gt;--&gt;
&lt;!--        &lt;i :class=&quot;typeClass&quot; v-else&gt;&lt;/i&gt;--&gt;
        &lt;svg-icon :iconClass=&quot;svgName&quot; className=&quot;message-alert&quot;&gt;&lt;/svg-icon&gt;
      &lt;/div&gt;

      &lt;slot&gt;
        &lt;p v-if=&quot;!dangerouslyUseHTMLString&quot; class=&quot;el-message__content&quot;&gt;
          {{ message }}
        &lt;/p&gt;
        &lt;p v-else v-html=&quot;message&quot; class=&quot;el-message__content&quot;&gt;&lt;/p&gt;
      &lt;/slot&gt;
      &lt;i
        v-if=&quot;showClose&quot;
        class=&quot;el-message__closeBtn el-icon-close&quot;
        @click=&quot;close&quot;
      &gt;&lt;/i&gt;
    &lt;/div&gt;
  &lt;/transition&gt;
&lt;/template&gt;
&lt;script type=&quot;text/babel&quot;&gt;
const typeMap = {
  success: &quot;success&quot;,
  info: &quot;info&quot;,
  warning: &quot;warning&quot;,
  error: &quot;error&quot;
};
export default {
  data() {
    return {
      visible: false,
      message: &quot;&quot;,
      duration: 1000,
      type: &quot;info&quot;,
      iconClass: &quot;&quot;,
      customClass: &quot;&quot;,
      onClose: null,
      showClose: false,
      closed: false,
      verticalOffset: 20,
      timer: null,
      dangerouslyUseHTMLString: false,
      center: false
    };
  },
  computed: {
    typeClass() {
      return this.type &amp;&amp; !this.iconClass
        ? `white--i-success el-icon-${typeMap[this.type]}`
        : &quot;&quot;;
    },
      //返回svg名称
      svgName(){
        if(this.type){
            return this.type
        }else{
            return &quot;success&quot;
        }
      },
    positionStyle() {
      return {
        top: `${this.verticalOffset}px`
      };
    }
  },
  watch: {
    closed(newVal) {
      if (newVal) {
        this.visible = false;
      }
    }
  },
  methods: {
    handleAfterLeave() {
      this.$destroy(true);
      this.$el.parentNode.removeChild(this.$el);
    },
    close() {
      this.closed = true;
      if (typeof this.onClose === &quot;function&quot;) {
        this.onClose(this);
      }
    },
    clearTimer() {
      clearTimeout(this.timer);
    },
    startTimer() {
      if (this.duration &gt; 0) {
        this.timer = setTimeout(() =&gt; {
          if (!this.closed) {
            this.close();
          }
        }, this.duration);
      }
    },
    keydown(e) {
      if (e.keyCode === 27) {
        // esc关闭消息
        if (!this.closed) {
          this.close();
        }
      }
    }
  },
  mounted() {
    this.startTimer();
    document.addEventListener(&quot;keydown&quot;, this.keydown);
  },
  beforeDestroy() {
    document.removeEventListener(&quot;keydown&quot;, this.keydown);
  }
};
&lt;/script&gt;
</code></pre>
<p>##封装.js部分</p>
<pre><code class="language-$xslt">import Vue from &quot;vue&quot;;
import Main from &quot;./main.vue&quot;;
// import { PopupManager } from 'element-ui/src/utils/popup';
// import { isVNode } from 'element-ui/src/utils/vdom';
const hasOwnProperty = Object.prototype.hasOwnProperty;

export function noop() {}

export function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
function isVNode(node) {
  return (
    node !== null &amp;&amp;
    typeof node === &quot;object&quot; &amp;&amp;
    hasOwn(node, &quot;componentOptions&quot;)
  );
}
let MessageConstructor = Vue.extend(Main);
let instance;
let instances = [];
let seed = 1;
const Message = function(options) {
  if (Vue.prototype.$isServer) return;
  options = options || {};
  if (typeof options === &quot;string&quot;) {
    options = {
      message: options
    };
  }
  let userOnClose = options.onClose;
  let id = &quot;message_&quot; + seed++;
  options.onClose = function() {
    Message.close(id, userOnClose);
  };
  instance = new MessageConstructor({
    data: options
  });
  instance.id = id;
  if (isVNode(instance.message)) {
    instance.$slots.default = [instance.message];
    instance.message = null;
  }
  instance.$mount();
  document.body.appendChild(instance.$el);
  let verticalOffset = options.offset || 20;
  instances.forEach(item =&gt; {
    verticalOffset += item.$el.offsetHeight + 16;
  });
  instance.verticalOffset = verticalOffset;
  instance.visible = true;
  instance.$el.style.zIndex = 10;
  instances.push(instance);
  return instance;
};
[&quot;success&quot;, &quot;warning&quot;, &quot;info&quot;, &quot;error&quot;].forEach(type =&gt; {
  Message[type] = options =&gt; {
    if (typeof options === &quot;string&quot;) {
      options = {
        message: options
      };
    }
    options.type = type;
    return Message(options);
  };
});
Message.close = function(id, userOnClose) {
  let len = instances.length;
  let index = -1;
  let removedHeight;
  for (let i = 0; i &lt; len; i++) {
    if (id === instances[i].id) {
      removedHeight = instances[i].$el.offsetHeight;
      index = i;
      if (typeof userOnClose === &quot;function&quot;) {
        userOnClose(instances[i]);
      }
      instances.splice(i, 1);
      break;
    }
  }
  if (len &lt;= 1 || index === -1 || index &gt; instances.length - 1) return;
  for (let i = index; i &lt; len - 1; i++) {
    let dom = instances[i].$el;
    dom.style[&quot;top&quot;] =
      parseInt(dom.style[&quot;top&quot;], 10) - removedHeight - 16 + &quot;px&quot;;
  }
};
Message.closeAll = function() {
  for (let i = instances.length - 1; i &gt;= 0; i--) {
    instances[i].close();
  }
};
export default Message;
</code></pre>
<p>##最后在需要调用的地方 引入即可  使用方式与element message类似</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[websocket封装在vuex中]]></title>
        <id>https://django-lee-tony.github.io/post/websocket-feng-zhuang-zai-vuex-zhong/</id>
        <link href="https://django-lee-tony.github.io/post/websocket-feng-zhuang-zai-vuex-zhong/">
        </link>
        <updated>2021-02-05T09:44:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="websocket封装暴露方法给vuex调用">websocket封装暴露方法给vuex调用</h1>
<h2 id="在vuex创建一个socket模块-用于连接以及接收消息">在vuex创建一个socket模块 用于连接以及接收消息</h2>
<pre><code class="language-$xslt">//socket.js
let timer,timer1;
import router from &quot;../../router&quot;;
import Socket from &quot;../../utils/socket&quot;;
    export default {
        state: {
            ws: null, // websorket实例
            wsAddress:null,//websocket地址
            visible:false,//页面弹窗显隐状态值
            acceptMessage:{},//接收的信息
        },
        mutations: {
            /**
             * 将socket赋值给ws 方便在组件中调用
             */
            CONTACT_SOCKET (state, { commit,dispatch }) {
                // let p=new Socket(commit,null,state.wsAddress)
                state.ws = new Socket(commit,dispatch,state.wsAddress?state.wsAddress:null);

            },
            /**
             * 接收消息
             */
            ACCEPT_MESSAGE(state,data){
                state.acceptMessage=data;
            },
            /**
             * 获取到init接口中的ws地址后 再将socket初始化连接
             */
            INSERT_SOCKET(state,val){
                if(val.value){
                    state.wsAddress=val.value
                }
            },
            /**
             * 关闭socket 在退出登录时触发
             */
            CLOSE_SOCKET(state){
                if(state.ws){
                    state.ws.$soctket_close();
                    state.ws=null
                }

                    // console.log(state.ws);
            },
            /**
             * 控制弹框的状态值
             */
            OPEN_DIALOG(state,flag){
                if(timer) clearTimeout(timer)
                if(flag){
                    timer=setTimeout(()=&gt;{
                        state.visible=false
                    },3000)
                }
                state.visible=flag
            },
        },
        actions: {
            /**
             * 请求得到ws地址后存入state
             */
            SOCKET_INIT ({commit, state},val) {
                commit('INSERT_SOCKET',val)//存入ws地址
            },
            /**
             * 初始化链接socket
             */
            CONTACT_SOCKET({dispatch,commit}){
                commit('CONTACT_SOCKET', { commit ,dispatch}) //把commit作为参数
            },
            /**
             * 接收消息
             */
            ['ACCEPT_MESSAGE']({dispatch,commit},data){
                let message=JSON.parse(data);
                let {action}=message;
                if(action==='KEEP_ALIVE') return ;
              
            }
        }
    }
</code></pre>
<h2 id="封装websocket">封装websocket</h2>
<pre><code class="language-$xslt">//utils/socket.js
/*
* socket长连接和公共管理方案
* websocket和 VueX 还有 Redux建立起长连接机制 ，防止在路由切换时候的时候断开连接，需要把socket实例放入公共管理统一处理
* 此方案暴露出一个触发器  api,方便任何组件调用 , 内部有一个订阅器api ，与 VueX 中 mutations
*/
import {getToken} from &quot;./permission&quot;;

let socketUrl = ''
/**
 * @param value
 * @returns {string}  强数据类型校验
 */

function isType (value) {
    return Object.prototype.toString.call(value).slice(8, -1)
}

/**
 * @param event 当前事件
 *  事件轮询器
 */
function eventPoll (event, outerConditon, time, callback) {
    let timer
    let currentCondition
    timer = clearInterval(() =&gt; {
        if (currentCondition === outerConditon) {
            clearInterval(timer)
            callback &amp;&amp; callback()
        }
        currentCondition = event()
    }, time)
}

function isSocketContent () {
    if (process.env.NODE_ENV === 'development') {
        socketUrl = 'ws://192.168.1.159:8088/ws'
    }
    else {
        socketUrl = 'wss://192.168.12.50:3333'
    }
}

/**
 * @constructor 构造函数
 * commit 公共管理触发器
 * action dispatch
 */

function socket (commit, actions,wsAddress) {
    if (isType(commit) !== 'Function') {
        throw new Error('commit must be a function')
    }
    this.wsAddress=wsAddress //socket地址
    this.commit = commit
    this.actions = actions || null
    this.timer = null
    this.errorResetNumber = 0 // 错误重连间隔
    this.closeWs = false
    this.errorFrom = 0 // socket断开来源
    this.errorResetTimer = null // 错误重连轮询
    this.errorDispatchOpen = true // 开启错误调度
    this.heartSocketOpen = false
    this.retry=0
    // isSocketContent()
    this.$soctket_init();

}
socket.prototype.$soctket_init = function (callback) {
    const _this = this
    if (_this.closeWs) {
        throw new Error('socket is closed ,$socker_init is fail ,  all methods is invalid')
    }
    const token = getToken()
    // const token=&quot;eyJhbGciOiJIUzI1NiJ9.eyJ3ZWJSb2xlIjoiYWRtaW4iLCJpZCI6IjMiLCJ1c2VybmFtZSI6ImJvc3MwMDIiLCJqdGkiOiIyZWUxM2I1ZWExNzU0NGUyYWZmOWJiNmRkMzc5NGVjYiIsInN1YiI6IlhCU3BvcnRzIiwiaWF0IjoxNjA4MTkwNzAzLCJleHAiOjE2NDA3Nzc5MDN9.UfuslVrqjGMOhdiIGqBhTW45mPOt_xaECGsBM7igvSM&amp;device=d&amp;retry=0&quot;
    // if (!token) {
    //     throw new Error('token  is undefined')
    // }
    const handerErrorMachine = () =&gt; {
        if (_this.errorResetNumber === 20) {
            _this.errorResetNumber = 0
            _this.errorResetTimer = null
            _this.errorFrom = 0
            _this.errorDispatchOpen = false
            _this.ws = null
            location.reload()
            // console.log('socket连接失败')
            return
        }
        _this.errorResetTimer = setTimeout(() =&gt; {
            _this.$soctket_init()
            _this.errorResetNumber++
        }, _this.errorResetNumber * 10000)
    }
    /**
     * 连接错误或者断开乱接
     * eventment 1 关闭 2连接错误
     */
    const errorDispatch = (eventment) =&gt; {
        let event = eventment
        return function () {
            if (_this.errorFrom === 0 &amp;&amp; _this.errorDispatchOpen) {
                _this.errorFrom = event
            }
            event === 1 ? console.log('web socket has failed  from closeState ') : console.log('web socket has failed  from errorState ')
            if (_this.errorFrom === event &amp;&amp; !_this.closeWs) {
                _this.errorResetTimer &amp;&amp; clearTimeout(_this.errorResetTimer)
                handerErrorMachine()
            }
        }
    }
    if (this.timer) clearTimeout(this.timer)
    //${this.wsAddress}ws://192.168.1.250:8088/ws
    _this.ws = new WebSocket(`${this.wsAddress}?token=${token}&amp;device=m&amp;retry=${_this.retry}`);
    _this.ws.onopen = function () {
        callback &amp;&amp; callback();
        _this.retry=1
        _this.errorResetNumber = 0
        _this.errorResetTimer = null
        _this.errorFrom = 0
        _this.errorDispatchOpen = true
        _this.$soctket_subscribe()
        _this.$soctket_heartSoctket()
        console.log('web socket has connected ')
    }

    _this.ws.onclose = errorDispatch(1);
    // _this.ws.onerror = errorDispatch(2)
}

/**
 * 触发器-&gt;发布信息
 * @param callback 状态处理
 * @param value 数据处理
 */
socket.prototype.$soctket_emit = function (value, callback) {
    const _this = this
    const poll = function () {
        return _this.ws.readyState
    }
    if (callback &amp;&amp; isType(callback) !== 'Function') {
        throw new Error('$socket_emit arugment[1] must be a function')
    }
    if (!_this.ws) {
        throw new Error('$socket dispatch is fail please use $socket_open method')
    }
    if (_this.ws.readyState === 1) { // 连接成功状态
        _this.ws.send(value)
        _this.$soctket_heartSoctket()
        callback &amp;&amp; callback()
    }
    else if (_this.ws.readyState === 0) { // 连接中状态 ，轮询查询连接
        eventPoll(poll, 1, 500, () =&gt; {
            _this.ws.send(value)
            _this.$soctket_heartSoctket()
            callback &amp;&amp; callback()
        })
    }
    else { // 失败重新连接
        _this.$soctket_init(() =&gt; {
            _this.$soctket_emit(value, callback)
        })
    }
}
/**
 * 订阅器-&gt;接受广播
 */
socket.prototype.$soctket_subscribe = function () {
    const _this = this
    _this.ws.onmessage = function (res) {
        // console.log(res.data);
        if (_this.actions) {
            if (isType(_this.actions) !== 'Function') {
                throw new Error('actions')
            } else {
                _this.actions('ACCEPT_MESSAGE',res.data)
            }
        } else {
            _this.commit('ACCEPT_MESSAGE',res.data);

        }
        // _this.$soctket_heartSoctket();
    }
}
/**
 * 发送心跳
 * 心脏搏动机制-&gt;防止断开连接
 */

socket.prototype.$soctket_heartSoctket = function () {
    if (this.timer) clearTimeout(this.timer)
    // console.log(this.timer)
    this.timer = setTimeout(() =&gt; {
        if (this.ws.readyState === 1 || this.ws.readyState === 0) {
            this.ws.send(JSON.stringify({ &quot;action&quot; : &quot;KEEP_ALIVE&quot;}))
            this.$soctket_heartSoctket()
        } else {
            this.$soctket_init()
        }
    }, 30000)
}
/**
 * 关闭socket连接
 */
socket.prototype.$soctket_close = function () {
    console.log(&quot;close&quot;);
    if (this.timer) clearTimeout(this.timer)
    if (this.errorResetTimer)clearTimeout(this.errorResetTimer)
    this.closeWs = true
    this.retry=0
    this.ws.close()
}
/**
 * 重启socket连接
 */
socket.prototype.$soctket_open = function () {
    if (!this.closeWs) {
        throw new Error('socket is connected')
    }
    this.timer = null
    this.errorResetNumber = 0
    this.closeWs = false
    this.errorFrom = 0
    this.errorResetTimer = null
    this.errorDispatchOpen = true
    this.heartSocketOpen = false
    this.closeWs = false
    this.$soctket_init()
}
export default socket


</code></pre>
]]></content>
    </entry>
</feed>