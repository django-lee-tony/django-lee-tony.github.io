<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://django-lee-tony.github.io</id>
    <title>django </title>
    <updated>2021-02-05T12:06:38.728Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://django-lee-tony.github.io"/>
    <link rel="self" href="https://django-lee-tony.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://django-lee-tony.github.io/images/avatar.png</logo>
    <icon>https://django-lee-tony.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, django </rights>
    <entry>
        <title type="html"><![CDATA[react学习 生命周期]]></title>
        <id>https://django-lee-tony.github.io/post/react-xue-xi-sheng-ming-zhou-qi/</id>
        <link href="https://django-lee-tony.github.io/post/react-xue-xi-sheng-ming-zhou-qi/">
        </link>
        <updated>2021-02-05T09:46:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="react">React</h1>
<h2 id="组件生命周期">组件生命周期</h2>
<p>每一个组件都有几个可以重写以让代码在处理环节的特定时期运行的“生命周期方法”。方法中带有前缀 will 的在特定环节之前被调用，而带有前缀 did 的方法则会在特定环节之后被调用</p>
<h3 id="装配">【装配】</h3>
<p>这些方法会在组件实例被创建和插入DOM中时被调用：</p>
<pre><code class="language-$xslt">constructor()
static getDerivedStateFromProps()
componentWillMount()（版本17之后失效）
render()
componentDidMount()
</code></pre>
<h3 id="更新">【更新】</h3>
<p>属性或状态的改变会触发一次更新。当一个组件在被重渲时，这些方法将会被调用：</p>
<pre><code class="language-$xslt">componentWillReceiveProps()（版本17之后失效）
static getDerivedStateFromProps()
shouldComponentUpdate()
componentWillUpdate() （版本17之后失效）
render()
getSnapshotBeforeUpdate()
componentDidUpdate()
</code></pre>
<h3 id="卸载">【卸载】</h3>
<p>当一个组件被从DOM中移除时，该方法被调用：<br>
componentWillUnmount()</p>
<h3 id="错误处理">【错误处理】</h3>
<p>在渲染过程中发生错误时会被调用<br>
<code>componentDidCatch()</code></p>
<h2 id="装配过程">装配过程</h2>
<h3 id="render">【render()】</h3>
<p>render()函数应该纯净，意味着其不应该改变组件的状态，其每次调用都应返回相同的结果，同时不直接和浏览器交互。若需要和浏览器交互，将任务放在componentDidMount()阶段或其他的生命周期方法<br>
render 函数应该是一个纯函数，完全根据this.state和this.props来决定返回的结果，而且不要产生任何副作用。在render函数中调用this.setState毫无疑问是错误的，因为一个纯函数不应该引起状态的改变</p>
<h3 id="constructorprops">【constructor(props)】</h3>
<p>React组件的构造函数将会在装配之前被调用。当为一个React.Component子类定义构造函数时，应该在任何其他的表达式之前调用super(props)。否则，this.props在构造函数中将是未定义，并可能引发异常</p>
<h3 id="static-getderivedstatefrompropsnextprops-prevstate">【static getDerivedStateFromProps(nextProps, prevState)】</h3>
<pre><code>组件实例化后和接受新属性时将会调用getDerivedStateFromProps。它应该返回一个对象来更新状态，或者返回null来表明新属性不需要更新任何状态
</code></pre>
<p>[注意1]如果父组件导致了组件的重新渲染，即使属性没有更新，这一方法也会被调用<br>
　　[注意2]调用this.setState() 通常不会触发 getDerivedStateFromProps()<br>
典型用法如下所示：<br>
<code>static getDerivedStateFromProps() { return { indexOfShowControl: -1 } }</code></p>
<h3 id="componentdidmount">【componentDidMount()】</h3>
<pre><code>componentDidMount()在组件被装配后立即调用。初始化使得DOM节点应该进行到这里。若需要从远端加载数据，这是一个适合实现网络请求的地方
在这个方法中调用setState()将会触发一次额外的渲染，但是它将在浏览器刷新屏幕之前发生。这保证了即使render()将会调用两次，但用户不会看到中间状态。谨慎使用这一模式，因为它常导致性能问题
</code></pre>
<h2 id="更新及卸载">更新及卸载</h2>
<h3 id="shouldcomponentupdatenextprops-nextstate">【shouldComponentUpdate(nextProps, nextState)】</h3>
<pre><code>　使用shouldComponentUpdate()可以让React知道当前状态或属性的改变是否不影响组件的输出。默认行为是在每一次状态的改变重渲，在大部分情况下应该依赖于默认行为
当接收到新属性或状态时，shouldComponentUpdate() 在渲染前被调用。默认为true
若该方法返回false，则componentWillUpdate()、componentDidUpdate()、render()将不会被调用
*** [注意]该方法并不会在初始化渲染或当使用forceUpdate()时被调用
</code></pre>
<h3 id="getsnapshotbeforeupdate">【getSnapshotBeforeUpdate()】</h3>
<pre><code>getSnapshotBeforeUpdate()在最新的渲染输出提交给DOM前将会立即调用。它让组件能去获得当前的值在它们可能要改变前。这一生命周期返回的任何值将会作为参数被传递给componentDidUpdate()
[注意]该方法必须与componentDidUpdate()方法一起使用
</code></pre>
<h3 id="componentdidupateprevprops-prevstate">【componentDidUpate(prevProps, prevState)】</h3>
<pre><code>componentDidUpdate()会在更新发生后立即被调用。该方法并不会在初始化渲染时调用。当组件被更新时，使用该方法是操作DOM的一次机会。这也是一个适合发送请求的地方
</code></pre>
<h3 id="componentwillunmount">【componentWillUnmount()】</h3>
<pre><code>componentWillUnmount()在组件被卸载和销毁之前立刻调用。可以在该方法里处理任何必要的清理工作，例如解绑定时器，取消网络请求，清理任何在componentDidMount环节创建的DOM元素
</code></pre>
<h2 id="强制渲染">强制渲染</h2>
<h3 id="componentforceupdatecallback">【component.forceUpdate(callback)】</h3>
<pre><code>　默认情况，当组件或状态发生改变，组件将会重渲。若render()方法依赖其他数据，可以通过调用forceUpdate()来告诉React组件需要重渲
调用forceUpdate()将会导致组件的 render()方法被调用，并忽略shouldComponentUpdate()。这将会触发每一个子组件的生命周期方法，涵盖每个子组件的shouldComponentUpdate() 方法。若当标签改变，React仅会更新DOM
通常应该尝试避免所有forceUpdate() 的用法并仅在render()函数里从this.props和this.state读取数据
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[create-project-of-vue2]]></title>
        <id>https://django-lee-tony.github.io/post/create-project-of-vue2/</id>
        <link href="https://django-lee-tony.github.io/post/create-project-of-vue2/">
        </link>
        <updated>2021-02-05T09:46:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="安装">安装</h1>
<h2 id="卸载旧版本">卸载旧版本：</h2>
<h3 id="如果你之前都是基于vue-cli2x你需要先卸载它">如果你之前都是基于vue-cli2.X,你需要先卸载它：</h3>
<pre><code>#卸载vue-cli 老版本的cli
npm uninstall -g vue-cli
</code></pre>
<h2 id="安装-2">安装</h2>
<pre><code>npm install -g @vue/cli  // 安装cli3.x
vue --version 或者 vue -V  //查看版本是否为3.x
</code></pre>
<h1 id="创建项目">创建项目</h1>
<pre><code class="language-$xslt">vue create my-project // 其中my-project为项目目录名称
</code></pre>
<h3 id="此处有两个选择">此处有两个选择：</h3>
<pre><code class="language-$xslt">default (babel, eslint) 默认配置 提供babel和eslint支持
Manually select features 自己手动去选择需要的配置
</code></pre>
<h3 id="选择手动后">选择手动后</h3>
<pre><code class="language-$xslt">对于每一项的功能，做一下简单阐述：
Babel 主要是对es6语法转换成兼容的js （选上）
TypeScript 支持使用TypeScript语法来编写代码
PWA PWA 支持
Router 支持vue路由配置插件（一般都会选择）
Vuex 支持vue程序状态管理模式 (一般都会选择)
CSS Pre-processors 支持css预处理器 （一般都会选择）
Linter / Formatter 支持代码风格检查和格式化 （选上）
Unit Testing 单元测试
E2E Testing E2E测试
</code></pre>
<h3 id="当我们需要自定义webpack相关配置的时候需要在项目根目录中创建vueconfigjs文件它会被vuecli-server自动加载相关配置内容官网将的很详细">当我们需要自定义webpack相关配置的时候需要在项目根目录中创建vue.config.js文件，它会被@vue/cli-server自动加载，相关配置内容官网将的很详细</h3>
<pre><code class="language-$xslt">当我们需要调整webpac k配置的时候，
可以通过chainWebpack属性进行链式操作，
这里有个技巧就是通过 vue inspect --mode production product.js 
或vue inspect &gt; development.js 
来导处生产和开发环境的配置文件，文件里面包含了链式访问的规则，
这样我们就可以通过链式操作来修改添加webpack配置。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[svg正确使用方式]]></title>
        <id>https://django-lee-tony.github.io/post/svg-zheng-que-shi-yong-fang-shi/</id>
        <link href="https://django-lee-tony.github.io/post/svg-zheng-que-shi-yong-fang-shi/">
        </link>
        <updated>2021-02-05T09:45:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="svg正确使用方式">svg正确使用方式</h1>
<h2 id="svg-sprite-loader-下载">svg-sprite-loader 下载</h2>
<pre><code class="language-$xslt">npm i svg-sprite-loader 或者 yarn add svg-sprite-loader
</code></pre>
<h2 id="新建vueconfigjs-创建srcassetssvg-文件夹-将svg放入该文件夹中">新建vue.config.js 创建src/assets/svg 文件夹  将svg放入该文件夹中</h2>
<pre><code class="language-$xslt">const path = require(&quot;path&quot;);
function resolve(dir) {
    return path.join(__dirname, &quot;.&quot;, dir);
}
module.exports={
    ...
    chainwebpack:config =&gt;{
        ...
    config.module.rules.delete(&quot;svg&quot;); //重点:删除默认配置中处理svg,
            //const svgRule = config.module.rule('svg')
            //svgRule.uses.clear()
            config.module
                .rule(&quot;svg-sprite-loader&quot;)
                .test(/\.svg$/)
                .include.add(resolve(&quot;src/assets/svg&quot;)) //处理svg目录
                .end()
                .use(&quot;svg-sprite-loader&quot;)
                .loader(&quot;svg-sprite-loader&quot;)
                .options({
                    symbolId: &quot;icon-[name]&quot;
                });
    }
}
</code></pre>
<h2 id="封装组件">封装组件</h2>
<h3 id="新建indexvue">新建index.vue</h3>
<pre><code class="language-$xslt">//index.vue
&lt;template&gt;
    &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot;&gt;
        &lt;use :xlink:href=&quot;iconName&quot;/&gt;
    &lt;/svg&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        name: 'SvgIcon',
        props: {
            iconClass: { //接收svg名称 注意就是svg文件名
                type: String,
                required: true
            },
            className: { //svg图标的属性 如通过font-sizee属性控制icon大小
                type: String,
                default: ''
            }
        },
        computed: {
            iconName() {
                return `#icon-${this.iconClass}`
            },
            svgClass() {
                if (this.className) {
                    return 'svg-icon ' + this.className
                } else {
                    return 'svg-icon'
                }
            }
        }
    }
&lt;/script&gt;
&lt;style scoped&gt;
    .svg-icon {
        width: 1em;
        height: 1em;
        vertical-align: -0.15em;
        fill: currentColor;
        overflow: hidden;
    }
&lt;/style&gt;

</code></pre>
<h3 id="indexjs文件">index.js文件</h3>
<pre><code class="language-$xslt">//使用webpack提供的 require.context方法 引入所有的svg
import svgIcon from &quot;./index.vue&quot;
const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)
const req = require.context('../../assets/svg', false, /\.svg$/)
requireAll(req)
// 暴露方法
export default {
    install(Vue){
        Vue.component('svgIcon',svgIcon);
    }
}
</code></pre>
<h2 id="使用方式">使用方式</h2>
<pre><code class="language-$xslt"> &lt;svg-icon  icon-class=&quot;svgname&quot; class-name=&quot;svgclass&quot;&gt;&lt;/svg-icon&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue封装message组件]]></title>
        <id>https://django-lee-tony.github.io/post/vue-feng-zhuang-message-zu-jian/</id>
        <link href="https://django-lee-tony.github.io/post/vue-feng-zhuang-message-zu-jian/">
        </link>
        <updated>2021-02-05T09:45:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基于-element-源码改造-再封装">基于 element 源码改造 再封装</h1>
<h2 id="先封装-vue部分">先封装 .vue部分</h2>
<pre><code class="language-$xslt">&lt;template&gt;
  &lt;transition name=&quot;el-message-fade&quot; @after-leave=&quot;handleAfterLeave&quot;&gt;
    &lt;div
      :class=&quot;[
        'bwg-message',
        type &amp;&amp; !iconClass ? `white-${type}` : '',
        center ? 'is-center' : '',
        showClose ? 'is-closable' : '',
        customClass
      ]&quot;
      :style=&quot;positionStyle&quot;
      v-show=&quot;visible&quot;
      @mouseenter=&quot;clearTimer&quot;
      @mouseleave=&quot;startTimer&quot;
      role=&quot;alert&quot;
    &gt;
      &lt;div&gt;
&lt;!--        &lt;i :class=&quot;iconClass&quot; v-if=&quot;iconClass&quot;&gt;&lt;/i&gt;--&gt;
&lt;!--        &lt;i :class=&quot;typeClass&quot; v-else&gt;&lt;/i&gt;--&gt;
        &lt;svg-icon :iconClass=&quot;svgName&quot; className=&quot;message-alert&quot;&gt;&lt;/svg-icon&gt;
      &lt;/div&gt;

      &lt;slot&gt;
        &lt;p v-if=&quot;!dangerouslyUseHTMLString&quot; class=&quot;el-message__content&quot;&gt;
          {{ message }}
        &lt;/p&gt;
        &lt;p v-else v-html=&quot;message&quot; class=&quot;el-message__content&quot;&gt;&lt;/p&gt;
      &lt;/slot&gt;
      &lt;i
        v-if=&quot;showClose&quot;
        class=&quot;el-message__closeBtn el-icon-close&quot;
        @click=&quot;close&quot;
      &gt;&lt;/i&gt;
    &lt;/div&gt;
  &lt;/transition&gt;
&lt;/template&gt;
&lt;script type=&quot;text/babel&quot;&gt;
const typeMap = {
  success: &quot;success&quot;,
  info: &quot;info&quot;,
  warning: &quot;warning&quot;,
  error: &quot;error&quot;
};
export default {
  data() {
    return {
      visible: false,
      message: &quot;&quot;,
      duration: 1000,
      type: &quot;info&quot;,
      iconClass: &quot;&quot;,
      customClass: &quot;&quot;,
      onClose: null,
      showClose: false,
      closed: false,
      verticalOffset: 20,
      timer: null,
      dangerouslyUseHTMLString: false,
      center: false
    };
  },
  computed: {
    typeClass() {
      return this.type &amp;&amp; !this.iconClass
        ? `white--i-success el-icon-${typeMap[this.type]}`
        : &quot;&quot;;
    },
      //返回svg名称
      svgName(){
        if(this.type){
            return this.type
        }else{
            return &quot;success&quot;
        }
      },
    positionStyle() {
      return {
        top: `${this.verticalOffset}px`
      };
    }
  },
  watch: {
    closed(newVal) {
      if (newVal) {
        this.visible = false;
      }
    }
  },
  methods: {
    handleAfterLeave() {
      this.$destroy(true);
      this.$el.parentNode.removeChild(this.$el);
    },
    close() {
      this.closed = true;
      if (typeof this.onClose === &quot;function&quot;) {
        this.onClose(this);
      }
    },
    clearTimer() {
      clearTimeout(this.timer);
    },
    startTimer() {
      if (this.duration &gt; 0) {
        this.timer = setTimeout(() =&gt; {
          if (!this.closed) {
            this.close();
          }
        }, this.duration);
      }
    },
    keydown(e) {
      if (e.keyCode === 27) {
        // esc关闭消息
        if (!this.closed) {
          this.close();
        }
      }
    }
  },
  mounted() {
    this.startTimer();
    document.addEventListener(&quot;keydown&quot;, this.keydown);
  },
  beforeDestroy() {
    document.removeEventListener(&quot;keydown&quot;, this.keydown);
  }
};
&lt;/script&gt;
</code></pre>
<p>##封装.js部分</p>
<pre><code class="language-$xslt">import Vue from &quot;vue&quot;;
import Main from &quot;./main.vue&quot;;
// import { PopupManager } from 'element-ui/src/utils/popup';
// import { isVNode } from 'element-ui/src/utils/vdom';
const hasOwnProperty = Object.prototype.hasOwnProperty;

export function noop() {}

export function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
function isVNode(node) {
  return (
    node !== null &amp;&amp;
    typeof node === &quot;object&quot; &amp;&amp;
    hasOwn(node, &quot;componentOptions&quot;)
  );
}
let MessageConstructor = Vue.extend(Main);
let instance;
let instances = [];
let seed = 1;
const Message = function(options) {
  if (Vue.prototype.$isServer) return;
  options = options || {};
  if (typeof options === &quot;string&quot;) {
    options = {
      message: options
    };
  }
  let userOnClose = options.onClose;
  let id = &quot;message_&quot; + seed++;
  options.onClose = function() {
    Message.close(id, userOnClose);
  };
  instance = new MessageConstructor({
    data: options
  });
  instance.id = id;
  if (isVNode(instance.message)) {
    instance.$slots.default = [instance.message];
    instance.message = null;
  }
  instance.$mount();
  document.body.appendChild(instance.$el);
  let verticalOffset = options.offset || 20;
  instances.forEach(item =&gt; {
    verticalOffset += item.$el.offsetHeight + 16;
  });
  instance.verticalOffset = verticalOffset;
  instance.visible = true;
  instance.$el.style.zIndex = 10;
  instances.push(instance);
  return instance;
};
[&quot;success&quot;, &quot;warning&quot;, &quot;info&quot;, &quot;error&quot;].forEach(type =&gt; {
  Message[type] = options =&gt; {
    if (typeof options === &quot;string&quot;) {
      options = {
        message: options
      };
    }
    options.type = type;
    return Message(options);
  };
});
Message.close = function(id, userOnClose) {
  let len = instances.length;
  let index = -1;
  let removedHeight;
  for (let i = 0; i &lt; len; i++) {
    if (id === instances[i].id) {
      removedHeight = instances[i].$el.offsetHeight;
      index = i;
      if (typeof userOnClose === &quot;function&quot;) {
        userOnClose(instances[i]);
      }
      instances.splice(i, 1);
      break;
    }
  }
  if (len &lt;= 1 || index === -1 || index &gt; instances.length - 1) return;
  for (let i = index; i &lt; len - 1; i++) {
    let dom = instances[i].$el;
    dom.style[&quot;top&quot;] =
      parseInt(dom.style[&quot;top&quot;], 10) - removedHeight - 16 + &quot;px&quot;;
  }
};
Message.closeAll = function() {
  for (let i = instances.length - 1; i &gt;= 0; i--) {
    instances[i].close();
  }
};
export default Message;
</code></pre>
<p>##最后在需要调用的地方 引入即可  使用方式与element message类似</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[websocket封装在vuex中]]></title>
        <id>https://django-lee-tony.github.io/post/websocket-feng-zhuang-zai-vuex-zhong/</id>
        <link href="https://django-lee-tony.github.io/post/websocket-feng-zhuang-zai-vuex-zhong/">
        </link>
        <updated>2021-02-05T09:44:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="websocket封装暴露方法给vuex调用">websocket封装暴露方法给vuex调用</h1>
<h2 id="在vuex创建一个socket模块-用于连接以及接收消息">在vuex创建一个socket模块 用于连接以及接收消息</h2>
<pre><code class="language-$xslt">//socket.js
let timer,timer1;
import router from &quot;../../router&quot;;
import Socket from &quot;../../utils/socket&quot;;
    export default {
        state: {
            ws: null, // websorket实例
            wsAddress:null,//websocket地址
            visible:false,//页面弹窗显隐状态值
            acceptMessage:{},//接收的信息
        },
        mutations: {
            /**
             * 将socket赋值给ws 方便在组件中调用
             */
            CONTACT_SOCKET (state, { commit,dispatch }) {
                // let p=new Socket(commit,null,state.wsAddress)
                state.ws = new Socket(commit,dispatch,state.wsAddress?state.wsAddress:null);

            },
            /**
             * 接收消息
             */
            ACCEPT_MESSAGE(state,data){
                state.acceptMessage=data;
            },
            /**
             * 获取到init接口中的ws地址后 再将socket初始化连接
             */
            INSERT_SOCKET(state,val){
                if(val.value){
                    state.wsAddress=val.value
                }
            },
            /**
             * 关闭socket 在退出登录时触发
             */
            CLOSE_SOCKET(state){
                if(state.ws){
                    state.ws.$soctket_close();
                    state.ws=null
                }

                    // console.log(state.ws);
            },
            /**
             * 控制弹框的状态值
             */
            OPEN_DIALOG(state,flag){
                if(timer) clearTimeout(timer)
                if(flag){
                    timer=setTimeout(()=&gt;{
                        state.visible=false
                    },3000)
                }
                state.visible=flag
            },
        },
        actions: {
            /**
             * 请求得到ws地址后存入state
             */
            SOCKET_INIT ({commit, state},val) {
                commit('INSERT_SOCKET',val)//存入ws地址
            },
            /**
             * 初始化链接socket
             */
            CONTACT_SOCKET({dispatch,commit}){
                commit('CONTACT_SOCKET', { commit ,dispatch}) //把commit作为参数
            },
            /**
             * 接收消息
             */
            ['ACCEPT_MESSAGE']({dispatch,commit},data){
                let message=JSON.parse(data);
                let {action}=message;
                if(action==='KEEP_ALIVE') return ;
              
            }
        }
    }
</code></pre>
<h2 id="封装websocket">封装websocket</h2>
<pre><code class="language-$xslt">//utils/socket.js
/*
* socket长连接和公共管理方案
* websocket和 VueX 还有 Redux建立起长连接机制 ，防止在路由切换时候的时候断开连接，需要把socket实例放入公共管理统一处理
* 此方案暴露出一个触发器  api,方便任何组件调用 , 内部有一个订阅器api ，与 VueX 中 mutations
*/
import {getToken} from &quot;./permission&quot;;

let socketUrl = ''
/**
 * @param value
 * @returns {string}  强数据类型校验
 */

function isType (value) {
    return Object.prototype.toString.call(value).slice(8, -1)
}

/**
 * @param event 当前事件
 *  事件轮询器
 */
function eventPoll (event, outerConditon, time, callback) {
    let timer
    let currentCondition
    timer = clearInterval(() =&gt; {
        if (currentCondition === outerConditon) {
            clearInterval(timer)
            callback &amp;&amp; callback()
        }
        currentCondition = event()
    }, time)
}

function isSocketContent () {
    if (process.env.NODE_ENV === 'development') {
        socketUrl = 'ws://192.168.1.159:8088/ws'
    }
    else {
        socketUrl = 'wss://192.168.12.50:3333'
    }
}

/**
 * @constructor 构造函数
 * commit 公共管理触发器
 * action dispatch
 */

function socket (commit, actions,wsAddress) {
    if (isType(commit) !== 'Function') {
        throw new Error('commit must be a function')
    }
    this.wsAddress=wsAddress //socket地址
    this.commit = commit
    this.actions = actions || null
    this.timer = null
    this.errorResetNumber = 0 // 错误重连间隔
    this.closeWs = false
    this.errorFrom = 0 // socket断开来源
    this.errorResetTimer = null // 错误重连轮询
    this.errorDispatchOpen = true // 开启错误调度
    this.heartSocketOpen = false
    this.retry=0
    // isSocketContent()
    this.$soctket_init();

}
socket.prototype.$soctket_init = function (callback) {
    const _this = this
    if (_this.closeWs) {
        throw new Error('socket is closed ,$socker_init is fail ,  all methods is invalid')
    }
    const token = getToken()
    // const token=&quot;eyJhbGciOiJIUzI1NiJ9.eyJ3ZWJSb2xlIjoiYWRtaW4iLCJpZCI6IjMiLCJ1c2VybmFtZSI6ImJvc3MwMDIiLCJqdGkiOiIyZWUxM2I1ZWExNzU0NGUyYWZmOWJiNmRkMzc5NGVjYiIsInN1YiI6IlhCU3BvcnRzIiwiaWF0IjoxNjA4MTkwNzAzLCJleHAiOjE2NDA3Nzc5MDN9.UfuslVrqjGMOhdiIGqBhTW45mPOt_xaECGsBM7igvSM&amp;device=d&amp;retry=0&quot;
    // if (!token) {
    //     throw new Error('token  is undefined')
    // }
    const handerErrorMachine = () =&gt; {
        if (_this.errorResetNumber === 20) {
            _this.errorResetNumber = 0
            _this.errorResetTimer = null
            _this.errorFrom = 0
            _this.errorDispatchOpen = false
            _this.ws = null
            location.reload()
            // console.log('socket连接失败')
            return
        }
        _this.errorResetTimer = setTimeout(() =&gt; {
            _this.$soctket_init()
            _this.errorResetNumber++
        }, _this.errorResetNumber * 10000)
    }
    /**
     * 连接错误或者断开乱接
     * eventment 1 关闭 2连接错误
     */
    const errorDispatch = (eventment) =&gt; {
        let event = eventment
        return function () {
            if (_this.errorFrom === 0 &amp;&amp; _this.errorDispatchOpen) {
                _this.errorFrom = event
            }
            event === 1 ? console.log('web socket has failed  from closeState ') : console.log('web socket has failed  from errorState ')
            if (_this.errorFrom === event &amp;&amp; !_this.closeWs) {
                _this.errorResetTimer &amp;&amp; clearTimeout(_this.errorResetTimer)
                handerErrorMachine()
            }
        }
    }
    if (this.timer) clearTimeout(this.timer)
    //${this.wsAddress}ws://192.168.1.250:8088/ws
    _this.ws = new WebSocket(`${this.wsAddress}?token=${token}&amp;device=m&amp;retry=${_this.retry}`);
    _this.ws.onopen = function () {
        callback &amp;&amp; callback();
        _this.retry=1
        _this.errorResetNumber = 0
        _this.errorResetTimer = null
        _this.errorFrom = 0
        _this.errorDispatchOpen = true
        _this.$soctket_subscribe()
        _this.$soctket_heartSoctket()
        console.log('web socket has connected ')
    }

    _this.ws.onclose = errorDispatch(1);
    // _this.ws.onerror = errorDispatch(2)
}

/**
 * 触发器-&gt;发布信息
 * @param callback 状态处理
 * @param value 数据处理
 */
socket.prototype.$soctket_emit = function (value, callback) {
    const _this = this
    const poll = function () {
        return _this.ws.readyState
    }
    if (callback &amp;&amp; isType(callback) !== 'Function') {
        throw new Error('$socket_emit arugment[1] must be a function')
    }
    if (!_this.ws) {
        throw new Error('$socket dispatch is fail please use $socket_open method')
    }
    if (_this.ws.readyState === 1) { // 连接成功状态
        _this.ws.send(value)
        _this.$soctket_heartSoctket()
        callback &amp;&amp; callback()
    }
    else if (_this.ws.readyState === 0) { // 连接中状态 ，轮询查询连接
        eventPoll(poll, 1, 500, () =&gt; {
            _this.ws.send(value)
            _this.$soctket_heartSoctket()
            callback &amp;&amp; callback()
        })
    }
    else { // 失败重新连接
        _this.$soctket_init(() =&gt; {
            _this.$soctket_emit(value, callback)
        })
    }
}
/**
 * 订阅器-&gt;接受广播
 */
socket.prototype.$soctket_subscribe = function () {
    const _this = this
    _this.ws.onmessage = function (res) {
        // console.log(res.data);
        if (_this.actions) {
            if (isType(_this.actions) !== 'Function') {
                throw new Error('actions')
            } else {
                _this.actions('ACCEPT_MESSAGE',res.data)
            }
        } else {
            _this.commit('ACCEPT_MESSAGE',res.data);

        }
        // _this.$soctket_heartSoctket();
    }
}
/**
 * 发送心跳
 * 心脏搏动机制-&gt;防止断开连接
 */

socket.prototype.$soctket_heartSoctket = function () {
    if (this.timer) clearTimeout(this.timer)
    // console.log(this.timer)
    this.timer = setTimeout(() =&gt; {
        if (this.ws.readyState === 1 || this.ws.readyState === 0) {
            this.ws.send(JSON.stringify({ &quot;action&quot; : &quot;KEEP_ALIVE&quot;}))
            this.$soctket_heartSoctket()
        } else {
            this.$soctket_init()
        }
    }, 30000)
}
/**
 * 关闭socket连接
 */
socket.prototype.$soctket_close = function () {
    console.log(&quot;close&quot;);
    if (this.timer) clearTimeout(this.timer)
    if (this.errorResetTimer)clearTimeout(this.errorResetTimer)
    this.closeWs = true
    this.retry=0
    this.ws.close()
}
/**
 * 重启socket连接
 */
socket.prototype.$soctket_open = function () {
    if (!this.closeWs) {
        throw new Error('socket is connected')
    }
    this.timer = null
    this.errorResetNumber = 0
    this.closeWs = false
    this.errorFrom = 0
    this.errorResetTimer = null
    this.errorDispatchOpen = true
    this.heartSocketOpen = false
    this.closeWs = false
    this.$soctket_init()
}
export default socket


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vux多模块应用]]></title>
        <id>https://django-lee-tony.github.io/post/vux-duo-mo-kuai-ying-yong/</id>
        <link href="https://django-lee-tony.github.io/post/vux-duo-mo-kuai-ying-yong/">
        </link>
        <updated>2021-02-05T09:44:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vuex多模块使用方式">vuex多模块使用方式</h1>
<h2 id="下载">下载</h2>
<pre><code class="language-$xslt">npm i vuex 或者 yarn add vuex
</code></pre>
<p>##应用<br>
在vue项目中 src 目录下创建store文件夹<br>
创建index.js文件 创建modules文件夹 项目中分出的模块放入此文件夹中</p>
<pre><code class="language-$xslt">import Vue from 'vue';
import Vuex from 'vuex';
Vue.use(Vuex);
/**
 * 配置多模块
 */
const files = require.context(&quot;./modules&quot;, false, /\.js$/);
const modules = {};
files.keys().forEach(key =&gt; {
  modules[key.replace(/(\.\/|\.js)/g, &quot;&quot;)] = files(key).default;
});
Object.keys(modules).forEach((key) =&gt; {
  modules[key][&quot;namespaced&quot;] = true;
});
export default new Vuex.Store({
  modules
})
</code></pre>
<h3 id="vuex提供的辅助函数">vuex提供的辅助函数</h3>
<pre><code class="language-$xslt">mapActions 触发action 
mapMutations 触发mutations
mapState 获取state中的值
mapGetters 获取getter 
</code></pre>
<h3 id="项目中使用">项目中使用</h3>
<pre><code class="language-$xslt">//.vue
    methods中触发
    ...mapActions(模块名,触发的actions方法)
    ...mapMutations(模块名,触发的mutations名)
    computed中触发
    ...mapState(模块名,获取的value)
//.js 在vuex模块中
    actions
    ['方法名 建议使用常量']({dispatch,commit,rootState}){
        dispatch(方法名,数据) //触发actions
        dispatch(模块名/方法名,数据,{root:true}) //触发其他模块的actions
        commit(方法名,数据) 触发mutations
        //触发其他模块的mutations同理actions
        rootState 可以获取其他模块的state value
    } //
    commit 
    ['方法名 建议使用常量'](state,data){} //state value修改
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue项目修改ico]]></title>
        <id>https://django-lee-tony.github.io/post/vue-xiang-mu-xiu-gai-ico/</id>
        <link href="https://django-lee-tony.github.io/post/vue-xiang-mu-xiu-gai-ico/">
        </link>
        <updated>2021-02-05T09:43:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="ico-修改基于vue-cli3">ico 修改基于vue-cli3</h1>
<h3 id="在开发vue项目的时候-经常会出现ico修改失败-于是网上搜索了一堆的解决方案">在开发vue项目的时候 经常会出现ico修改失败 于是网上搜索了一堆的解决方案</h3>
<pre><code class="language-$xslt">
1 , &lt;link rel=&quot;icon&quot; href=&quot;./icon.ico&quot;&gt; //手动更改 开发和生产都无效
2,通过在 vue.config.js 手动设置pwa 无效
    pwa:{
        iconPaths:{
            ....
        }
    }
3,通过js动态去设置 无效
    (()=&gt;{
      var link = document.querySelector(&quot;link[rel*='manifest']&quot;);
        link.rel=&quot;ico&quot;
        link.href=&quot;图片路径&quot;
      document.getElementsByTagName('head')[0].appendChild(main);
    })() 
4,手动强制修改 &lt;link rel=&quot;icon&quot;  href=&quot;./img/&lt;%= VUE_APP_NODE %&gt;.ico&quot; type=&quot;image/x-icon&quot; /&gt; 无效
 最后直接删除public下的img 文件夹  虽然生效 但是页面会报错   崩溃
</code></pre>
<h2 id="生效的解决方案">生效的解决方案</h2>
<pre><code class="language-$xslt">1,
    手动删除 public/img文件夹
//解决页面报错
        (()=&gt;{
          var main = document.querySelector(&quot;link[rel*='manifest']&quot;);
          document.getElementsByTagName('head')[0].removeChild(main);
        })();
    //然后再手动设置
    &lt;link rel=&quot;icon&quot;  href=&quot;./img/&lt;%= VUE_APP_NODE %&gt;.ico&quot; type=&quot;image/x-icon&quot; /&gt;
此时刷新页面 生效并且无报错
2,通过再vue.config.js中设置 动态加入到 htmlWebpackPlugin中
 chainWebpack: config =&gt; {
        config.plugin('html').tap((options) =&gt; {
            options[0].title= process.env.VUE_APP_TITLE//设置项目名称
            // options[0].favicon='public/img/rora.ico' //设置ico
            // options[0].BASE_URL= &quot;./favicon/&quot; //设置relicon
            // options[0].BASE_URL_VARIABLE= process.env.VUE_APP_VARIABLE //设置relicon
            return options
        })
    }
    然后可以直接在index.html中使用 
    &lt;link rel=&quot;icon&quot;  href=&quot;&lt;%=  htmlWebpackPlugin.options.favicon %&gt;&quot; type=&quot;image/x-icon&quot; /&gt;
    此方法生效 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[移动端常见问题处理]]></title>
        <id>https://django-lee-tony.github.io/post/yi-dong-duan-chang-jian-wen-ti-chu-li/</id>
        <link href="https://django-lee-tony.github.io/post/yi-dong-duan-chang-jian-wen-ti-chu-li/">
        </link>
        <updated>2021-02-05T09:41:05.000Z</updated>
        <content type="html"><![CDATA[<hr>
<h2 id="title-移动端常见问题处理date-2021-02-04-162101tags">title: 移动端常见问题处理<br>
date: 2021-02-04 16:21:01<br>
tags:</h2>
<h1 id="本文将详细介绍移动web开发中的常见问题">本文将详细介绍移动web开发中的常见问题</h1>
<h1 id="移动端常见问题处理">移动端常见问题处理</h1>
<h2 id="input">input</h2>
<h3 id="光标颜色">【光标颜色】</h3>
<p>默认情况下，光标颜色与字体颜色color相同，但也可以通过caret-color属性来单独设置</p>
<pre><code class="language-$xslt">caret-color: auto;
caret-color: transparent;
caret-color: currentColor;
caret-color: red;
caret-color: #5729e9;
caret-color: rgb(0, 200, 0);
caret-color: hsla(228, 4%, 24%, 0.8);
//但是，IOS的光标不支持caret-color，与字体颜色无关，默认为紫蓝色。所以，尽量不要设置蓝色或紫色背景，否则光标看不清楚
</code></pre>
<h3 id="光标高度">【光标高度】</h3>
<p>input域的光标高度与行高line-height相同，所以不要设置太高的行高，可以通过设置上下padding来撑开高度</p>
<pre><code class="language-$xslt">input{
line-height:20px; 
padding:15px;
}
</code></pre>
<h3 id="放大">【放大】</h3>
<p>IOS下，input获取焦点时会放大，meta设置user-scalable=no，可取消放大效果</p>
<pre><code class="language-$xslt">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no, shrink-to-fit=no&quot;&gt;
</code></pre>
<h3 id="自动大写">【自动大写】</h3>
<p>一般地，IOS下默认开启键盘的首字母自动大写功能，这样输入英文的时候，首字母便会自动大写<br>
 但是，有些时候并不希望一直是首字母大写的。比如用户名这个字段，如果字段本身就是区分大小写的，首字母自动大写往往会给用户带来麻烦。可以通过在表单元素上可以通过设置autocapitalize=&quot;off&quot;来关闭</p>
<pre><code class="language-$xslt"> &lt;input type=&quot;text&quot; autocapitalize=&quot;off&quot;&gt;
</code></pre>
<h3 id="圆角">【圆角】</h3>
<p>IOS下，input域只显示底边框时，会出现两个底部底边圆角效果，设置border-radius:0即可</p>
<pre><code class="language-$xslt">border-radius:0
</code></pre>
<h3 id="自动保存">【自动保存】</h3>
<p>input域默认会开启自动保存功能，可以使用autocomplete=&quot;off&quot;属性将其关闭</p>
<pre><code class="language-$xslt">&lt;input autocomplete=&quot;off&quot; /&gt; //要特别注意的是，如果使用react框架，需要将autocomplete替换为autoComplete这种小驼峰形式
</code></pre>
<h3 id="轮廓outline">【轮廓outline】</h3>
<p>android浏览器下，input域处于焦点状态时，默认会有一圈淡黄色的轮廓outline效果<br>
通过设置outline:none可将其去除</p>
<pre><code class="language-$xslt">outline: none
</code></pre>
<h3 id="虚拟键盘">【虚拟键盘】</h3>
<p>IOS弹出虚拟键盘不影响可视区域大小，而android手机弹出虚拟键盘时会影响。<br>
所以，最好将包含input域的页面高度设为固定在页面初始化时，获取页面高度</p>
<pre><code class="language-$xslt">// app.js
  componentDidMount() {
    const { setWrapSize } = this.props
    const { clientHeight, clientWidth } = document.documentElement
    setWrapSize({ clientHeight, clientWidth })
    window.addEventListener('orientationchange', this.setSize)
  }
 然后通过行间样式，将此高度设置到包含input域的页面上
// BaseFullScreen
&lt;Wrap className={className} style={{ height: `${wrapHeight}px` }} {...rest}&gt;{children}&lt;/Wrap&gt;
</code></pre>
<h2 id="样式">样式</h2>
<h3 id="点击背景">【点击背景】</h3>
<p>在移动端，点击可点击元素时，android下会出现淡蓝色背景，IOS下会出现灰色背景<br>
可以通过-webkt-tap-hightlight-color属性的设置，取消点击时出现的背景效果</p>
<pre><code class="language-$xslt">* {
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}
</code></pre>
<h3 id="appearance">【appearance】</h3>
<p>使用appearance:none主要用来去除表单类元素的中浏览器内置样式，如去除data类型input域的叉叉，去除number类型input域的上下箭头等</p>
<pre><code class="language-$xslt">input[type=number]{
  -webkit-appearance: none;
}
</code></pre>
<h3 id="禁止选中">【禁止选中】</h3>
<p>有时不希望用户在网站上选择文本，或许是出于版权的原因，如电子书网站。通常使用js来实现<br>
另一个方案就是，将-webkit-user-select设为none</p>
<pre><code class="language-$xslt">-webkit-user-select：none;
但是此方法在safari有兼容性 会导致输入框光标消失
//最终的解决方案 
body:not(input,textarea) {
  -webkit-user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  user-select: none;
}
input, textarea {
  -webkit-user-select: auto !important;
  -khtml-user-select: auto !important;
  -moz-user-select: auto !important;
  -ms-user-select: auto !important;
  -o-user-select: auto !important;
  user-select: auto !important;
}
</code></pre>
<h3 id="禁止文字缩放">【禁止文字缩放】</h3>
<p>部分手机上，切换横竖屏时，会缩放字体。使用如下设置，可以禁止文字缩放</p>
<pre><code class="language-$xslt">* {
  -webkit-text-size-adjust:100%;
}
</code></pre>
<h3 id="文本渲染">【文本渲染】</h3>
<p>使用text-rendering:optimizeLegibility属性，<br>
可以让浏览器在绘制文本时将着重考虑易读性，而不是渲染速度和几何精度.它会使字间距和连字有效</p>
<pre><code>text-rendering: optimizeLegibility; //该属性在移动设备上会造成比较明显的性能问题
</code></pre>
<h3 id="文本平滑显示">【文本平滑显示】</h3>
<p>-webkit-font-smoothing属性可以用来控制字体的像素显示是否平滑</p>
<pre><code class="language-$xslt">none 关闭抗锯齿，字体边缘犀利。
antialiased 字体像素级平滑，在深色背景上会让文字看起来更细了
subpixel-antialiased 字体亚像素级平滑，主要为了在非视网膜设备下更好的显示
body { -webkit-font-smoothing: antialiased; }
</code></pre>
<h3 id="滚动回弹">【滚动回弹】</h3>
<p>-webkit-overflow-scrolling 属性控制元素在移动设备上是否使用滚动回弹效果</p>
<pre><code class="language-$xslt">auto 使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止
touch 使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。
        继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文
body {
  -webkit-overflow-scrolling: touch;
}
一定要设置该属性，否则在IOS下会出现局部滚动不流畅的bug
</code></pre>
<h3 id="1倍行高">【1倍行高】</h3>
<p>设置line-height:1，即行高为1时，有的页面会出现文字显示不全的情况，所以行高设置一定要大于1</p>
<h3 id="1像素边框">【1像素边框】</h3>
<p>由于retina屏的原因，1px 的 border 会显示成两个物理像素，所以看起来会感觉很粗，这是一个移动端开发常见的问题<br>
解决方案有很多，但都有自己的优缺点<br>
1、0.5px 边框<br>
  从iOS 8开始，iOS 浏览器支持 0.5px 的 border，但是在 Android 上是不支持的，0.5px 会被认为是 0px，所以这种方法，兼容性很差<br>
2、背景渐变<br>
  CSS3 有了渐变背景，可以通过渐变背景实现 1px 的 border，实现原理是设置 1px 的渐变背景，50% 有颜色，50% 是透明的<br>
<code>@mixin commonStyle() { background-size: 100% 1px,1px 100% ,100% 1px, 1px 100%; background-repeat: no-repeat; background-position: top, right top, bottom, left top; } @mixin border($border-color) { @include commonStyle(); background-image:linear-gradient(180deg, $border-color, $border-color 50%, transparent 50%), linear-gradient(270deg, $border-color, $border-color 50%, transparent 50%), linear-gradient(0deg, $border-color, $border-color 50%, transparent 50%), linear-gradient(90deg, $border-color, $border-color 50%, transparent 50%); }</code><br>
3、伪类 + transform<br>
这类方法的实现原理是用伪元素高度设置为1px，然后用 transform缩小到原来的一半<br>
<code>div { position: relative; &amp;::after { position: absolute; left: 0; right: 0; height: 1px; transform: scaleY(.5); content: ''; }</code></p>
<h3 id="页面放大">【页面放大】</h3>
<p>在移动端页面双击 或者使用手指缩放的时候 页面会跟随方法缩小 体验性较差<br>
解决方案</p>
<pre><code class="language-$xslt">&lt;!--    强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户点击屏幕放大浏览。--&gt;
   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover&quot;&gt;
//但是此方法在safari上还是会有一定的兼容性 依旧会放大 此时应使用js控制
   document.addEventListener('gesturestart', function(event) {
     event.preventDefault();
   });

</code></pre>
<h3 id="浏览器左右滑动">【浏览器左右滑动】</h3>
<pre><code>通常用户在浏览器左右滑动时 页面会返回到上一层页面 或者出现退出的情况   体验比较差
```$xslt
var startX,startY;
    document.addEventListener(&quot;touchstart&quot;,function(e){
      startX = e.targetTouches[0].pageX;
      startY = e.targetTouches[0].pageY;
    });
    document.addEventListener(&quot;touchmove&quot;,function(e){
      // e.preventDefault();
      var moveX = e.targetTouches[0].pageX;
      var moveY = e.targetTouches[0].pageY;

      if(Math.abs(moveX-startX)&gt;Math.abs(moveY-startY)){
        e.preventDefault();
      }
    },{passive:false});

```
</code></pre>
<h2 id="布局">布局</h2>
<h3 id="vh">【vh】</h3>
<p>页面使用vh来控制元素高度的时候，在安卓端浏览器虚拟键盘弹出时，导致视口高度改变，以至于vh的取值改变 在safari也有一定的兼容性</p>
<pre><code class="language-$xslt">   // 正常模式下
   100vh = document.documentElement.clientHeight;
   // 安卓端弹出虚拟键盘情况下
   100vh = document.documentElement.clientHeight - 虚拟键盘的高度;
   //在safari上 如果先隐藏地址栏 再开启地址栏时 页面高度同样会计算错误  
   所以页面应避免使用100vh
</code></pre>
<h2 id="浏览器">浏览器</h2>
<h3 id="添加到主屏幕">【添加到主屏幕】</h3>
<p>在IOS下，在head元素底部，使用下列代码可以实现添加到主屏幕的功能</p>
<pre><code class="language-$xslt"> &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;
  &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;
  &lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;Weather PWA&quot;&gt;
  &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;images/icons/icon-152x152.png&quot;&gt;
</code></pre>
<h3 id="qq浏览器">【QQ浏览器】</h3>
<pre><code class="language-$xslt">// 全屏模式
&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;
// 强制竖屏
&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;
// 强制横屏
&lt;meta name=&quot;x5-orientation&quot; content=&quot;landscape&quot;&gt;
// 应用模式
&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;
</code></pre>
<h3 id="uc浏览器">【UC浏览器】</h3>
<pre><code class="language-$xslt">// 全屏模式
&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;
// 强制竖屏
&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;
// 强制横屏
&lt;meta name=&quot;screen-orientation&quot; content=&quot;landscape&quot;&gt;
// 应用模式
&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;
</code></pre>
]]></content>
    </entry>
</feed>